// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: db.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_db_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_db_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_db_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_db_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_db_2eproto;
namespace condenccpp {
class ConfigHeader;
struct ConfigHeaderDefaultTypeInternal;
extern ConfigHeaderDefaultTypeInternal _ConfigHeader_default_instance_;
class EncHeaderData;
struct EncHeaderDataDefaultTypeInternal;
extern EncHeaderDataDefaultTypeInternal _EncHeaderData_default_instance_;
class Header;
struct HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class Log;
struct LogDefaultTypeInternal;
extern LogDefaultTypeInternal _Log_default_instance_;
class Logs;
struct LogsDefaultTypeInternal;
extern LogsDefaultTypeInternal _Logs_default_instance_;
class PaillierPK;
struct PaillierPKDefaultTypeInternal;
extern PaillierPKDefaultTypeInternal _PaillierPK_default_instance_;
class PwdCtxORPredicate;
struct PwdCtxORPredicateDefaultTypeInternal;
extern PwdCtxORPredicateDefaultTypeInternal _PwdCtxORPredicate_default_instance_;
class TypoPolicy;
struct TypoPolicyDefaultTypeInternal;
extern TypoPolicyDefaultTypeInternal _TypoPolicy_default_instance_;
class WaitlistEntry;
struct WaitlistEntryDefaultTypeInternal;
extern WaitlistEntryDefaultTypeInternal _WaitlistEntry_default_instance_;
class typoDB;
struct typoDBDefaultTypeInternal;
extern typoDBDefaultTypeInternal _typoDB_default_instance_;
}  // namespace condenccpp
PROTOBUF_NAMESPACE_OPEN
template<> ::condenccpp::ConfigHeader* Arena::CreateMaybeMessage<::condenccpp::ConfigHeader>(Arena*);
template<> ::condenccpp::EncHeaderData* Arena::CreateMaybeMessage<::condenccpp::EncHeaderData>(Arena*);
template<> ::condenccpp::Header* Arena::CreateMaybeMessage<::condenccpp::Header>(Arena*);
template<> ::condenccpp::Log* Arena::CreateMaybeMessage<::condenccpp::Log>(Arena*);
template<> ::condenccpp::Logs* Arena::CreateMaybeMessage<::condenccpp::Logs>(Arena*);
template<> ::condenccpp::PaillierPK* Arena::CreateMaybeMessage<::condenccpp::PaillierPK>(Arena*);
template<> ::condenccpp::PwdCtxORPredicate* Arena::CreateMaybeMessage<::condenccpp::PwdCtxORPredicate>(Arena*);
template<> ::condenccpp::TypoPolicy* Arena::CreateMaybeMessage<::condenccpp::TypoPolicy>(Arena*);
template<> ::condenccpp::WaitlistEntry* Arena::CreateMaybeMessage<::condenccpp::WaitlistEntry>(Arena*);
template<> ::condenccpp::typoDB* Arena::CreateMaybeMessage<::condenccpp::typoDB>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace condenccpp {

enum SystemStatus : int {
  ALL_GOOD = 0,
  PW_CHANGED = 1,
  UNINITIALIZED = 3
};
bool SystemStatus_IsValid(int value);
constexpr SystemStatus SystemStatus_MIN = ALL_GOOD;
constexpr SystemStatus SystemStatus_MAX = UNINITIALIZED;
constexpr int SystemStatus_ARRAYSIZE = SystemStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SystemStatus_descriptor();
template<typename T>
inline const std::string& SystemStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SystemStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SystemStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SystemStatus_descriptor(), enum_t_value);
}
inline bool SystemStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SystemStatus>(
    SystemStatus_descriptor(), name, value);
}
// ===================================================================

class TypoPolicy final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:condenccpp.TypoPolicy) */ {
 public:
  inline TypoPolicy() : TypoPolicy(nullptr) {}
  ~TypoPolicy() override;
  explicit PROTOBUF_CONSTEXPR TypoPolicy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TypoPolicy(const TypoPolicy& from);
  TypoPolicy(TypoPolicy&& from) noexcept
    : TypoPolicy() {
    *this = ::std::move(from);
  }

  inline TypoPolicy& operator=(const TypoPolicy& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypoPolicy& operator=(TypoPolicy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TypoPolicy& default_instance() {
    return *internal_default_instance();
  }
  static inline const TypoPolicy* internal_default_instance() {
    return reinterpret_cast<const TypoPolicy*>(
               &_TypoPolicy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TypoPolicy& a, TypoPolicy& b) {
    a.Swap(&b);
  }
  inline void Swap(TypoPolicy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypoPolicy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypoPolicy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TypoPolicy>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TypoPolicy& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TypoPolicy& from) {
    TypoPolicy::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TypoPolicy* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "condenccpp.TypoPolicy";
  }
  protected:
  explicit TypoPolicy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEditCutoffFieldNumber = 1,
    kAbsEntcutoffFieldNumber = 2,
    kRelEntcutoffFieldNumber = 3,
    kMinLengthFieldNumber = 4,
  };
  // optional int32 edit_cutoff = 1 [default = 1];
  bool has_edit_cutoff() const;
  private:
  bool _internal_has_edit_cutoff() const;
  public:
  void clear_edit_cutoff();
  int32_t edit_cutoff() const;
  void set_edit_cutoff(int32_t value);
  private:
  int32_t _internal_edit_cutoff() const;
  void _internal_set_edit_cutoff(int32_t value);
  public:

  // optional int32 abs_entcutoff = 2 [default = 10];
  bool has_abs_entcutoff() const;
  private:
  bool _internal_has_abs_entcutoff() const;
  public:
  void clear_abs_entcutoff();
  int32_t abs_entcutoff() const;
  void set_abs_entcutoff(int32_t value);
  private:
  int32_t _internal_abs_entcutoff() const;
  void _internal_set_abs_entcutoff(int32_t value);
  public:

  // optional int32 rel_entcutoff = 3 [default = 3];
  bool has_rel_entcutoff() const;
  private:
  bool _internal_has_rel_entcutoff() const;
  public:
  void clear_rel_entcutoff();
  int32_t rel_entcutoff() const;
  void set_rel_entcutoff(int32_t value);
  private:
  int32_t _internal_rel_entcutoff() const;
  void _internal_set_rel_entcutoff(int32_t value);
  public:

  // optional int32 min_length = 4 [default = 6];
  bool has_min_length() const;
  private:
  bool _internal_has_min_length() const;
  public:
  void clear_min_length();
  int32_t min_length() const;
  void set_min_length(int32_t value);
  private:
  int32_t _internal_min_length() const;
  void _internal_set_min_length(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:condenccpp.TypoPolicy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t edit_cutoff_;
    int32_t abs_entcutoff_;
    int32_t rel_entcutoff_;
    int32_t min_length_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class Log final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:condenccpp.Log) */ {
 public:
  inline Log() : Log(nullptr) {}
  ~Log() override;
  explicit PROTOBUF_CONSTEXPR Log(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Log(const Log& from);
  Log(Log&& from) noexcept
    : Log() {
    *this = ::std::move(from);
  }

  inline Log& operator=(const Log& from) {
    CopyFrom(from);
    return *this;
  }
  inline Log& operator=(Log&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Log& default_instance() {
    return *internal_default_instance();
  }
  static inline const Log* internal_default_instance() {
    return reinterpret_cast<const Log*>(
               &_Log_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Log& a, Log& b) {
    a.Swap(&b);
  }
  inline void Swap(Log* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Log* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Log* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Log>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Log& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Log& from) {
    Log::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Log* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "condenccpp.Log";
  }
  protected:
  explicit Log(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocaltimeFieldNumber = 8,
    kInCacheFieldNumber = 1,
    kIstop5FixableFieldNumber = 2,
    kEditDistFieldNumber = 3,
    kRelEntropyFieldNumber = 4,
    kPassComplexityFieldNumber = 5,
    kTsFieldNumber = 7,
    kTidFieldNumber = 6,
  };
  // required string localtime = 8;
  bool has_localtime() const;
  private:
  bool _internal_has_localtime() const;
  public:
  void clear_localtime();
  const std::string& localtime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_localtime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_localtime();
  PROTOBUF_NODISCARD std::string* release_localtime();
  void set_allocated_localtime(std::string* localtime);
  private:
  const std::string& _internal_localtime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_localtime(const std::string& value);
  std::string* _internal_mutable_localtime();
  public:

  // required bool in_cache = 1;
  bool has_in_cache() const;
  private:
  bool _internal_has_in_cache() const;
  public:
  void clear_in_cache();
  bool in_cache() const;
  void set_in_cache(bool value);
  private:
  bool _internal_in_cache() const;
  void _internal_set_in_cache(bool value);
  public:

  // required bool istop5fixable = 2;
  bool has_istop5fixable() const;
  private:
  bool _internal_has_istop5fixable() const;
  public:
  void clear_istop5fixable();
  bool istop5fixable() const;
  void set_istop5fixable(bool value);
  private:
  bool _internal_istop5fixable() const;
  void _internal_set_istop5fixable(bool value);
  public:

  // required int32 edit_dist = 3;
  bool has_edit_dist() const;
  private:
  bool _internal_has_edit_dist() const;
  public:
  void clear_edit_dist();
  int32_t edit_dist() const;
  void set_edit_dist(int32_t value);
  private:
  int32_t _internal_edit_dist() const;
  void _internal_set_edit_dist(int32_t value);
  public:

  // required float rel_entropy = 4;
  bool has_rel_entropy() const;
  private:
  bool _internal_has_rel_entropy() const;
  public:
  void clear_rel_entropy();
  float rel_entropy() const;
  void set_rel_entropy(float value);
  private:
  float _internal_rel_entropy() const;
  void _internal_set_rel_entropy(float value);
  public:

  // required float pass_complexity = 5;
  bool has_pass_complexity() const;
  private:
  bool _internal_has_pass_complexity() const;
  public:
  void clear_pass_complexity();
  float pass_complexity() const;
  void set_pass_complexity(float value);
  private:
  float _internal_pass_complexity() const;
  void _internal_set_pass_complexity(float value);
  public:

  // required int64 ts = 7;
  bool has_ts() const;
  private:
  bool _internal_has_ts() const;
  public:
  void clear_ts();
  int64_t ts() const;
  void set_ts(int64_t value);
  private:
  int64_t _internal_ts() const;
  void _internal_set_ts(int64_t value);
  public:

  // required uint32 tid = 6;
  bool has_tid() const;
  private:
  bool _internal_has_tid() const;
  public:
  void clear_tid();
  uint32_t tid() const;
  void set_tid(uint32_t value);
  private:
  uint32_t _internal_tid() const;
  void _internal_set_tid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:condenccpp.Log)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr localtime_;
    bool in_cache_;
    bool istop5fixable_;
    int32_t edit_dist_;
    float rel_entropy_;
    float pass_complexity_;
    int64_t ts_;
    uint32_t tid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class ConfigHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:condenccpp.ConfigHeader) */ {
 public:
  inline ConfigHeader() : ConfigHeader(nullptr) {}
  ~ConfigHeader() override;
  explicit PROTOBUF_CONSTEXPR ConfigHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigHeader(const ConfigHeader& from);
  ConfigHeader(ConfigHeader&& from) noexcept
    : ConfigHeader() {
    *this = ::std::move(from);
  }

  inline ConfigHeader& operator=(const ConfigHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigHeader& operator=(ConfigHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigHeader* internal_default_instance() {
    return reinterpret_cast<const ConfigHeader*>(
               &_ConfigHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ConfigHeader& a, ConfigHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConfigHeader& from) {
    ConfigHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "condenccpp.ConfigHeader";
  }
  protected:
  explicit ConfigHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstallIdFieldNumber = 7,
    kPublicKeyFieldNumber = 8,
    kGlobalSaltFieldNumber = 9,
    kTpFieldNumber = 6,
    kPeriodForSendingLogFieldNumber = 2,
    kAllowedTypoLoginFieldNumber = 1,
    kExpireTyposFieldNumber = 3,
    kAllowUploadFieldNumber = 5,
    kTypoExpiryTimeFieldNumber = 4,
  };
  // required string install_id = 7;
  bool has_install_id() const;
  private:
  bool _internal_has_install_id() const;
  public:
  void clear_install_id();
  const std::string& install_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_install_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_install_id();
  PROTOBUF_NODISCARD std::string* release_install_id();
  void set_allocated_install_id(std::string* install_id);
  private:
  const std::string& _internal_install_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_install_id(const std::string& value);
  std::string* _internal_mutable_install_id();
  public:

  // required bytes public_key = 8;
  bool has_public_key() const;
  private:
  bool _internal_has_public_key() const;
  public:
  void clear_public_key();
  const std::string& public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_key();
  PROTOBUF_NODISCARD std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // required bytes global_salt = 9;
  bool has_global_salt() const;
  private:
  bool _internal_has_global_salt() const;
  public:
  void clear_global_salt();
  const std::string& global_salt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_global_salt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_global_salt();
  PROTOBUF_NODISCARD std::string* release_global_salt();
  void set_allocated_global_salt(std::string* global_salt);
  private:
  const std::string& _internal_global_salt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_global_salt(const std::string& value);
  std::string* _internal_mutable_global_salt();
  public:

  // optional .condenccpp.TypoPolicy tp = 6;
  bool has_tp() const;
  private:
  bool _internal_has_tp() const;
  public:
  void clear_tp();
  const ::condenccpp::TypoPolicy& tp() const;
  PROTOBUF_NODISCARD ::condenccpp::TypoPolicy* release_tp();
  ::condenccpp::TypoPolicy* mutable_tp();
  void set_allocated_tp(::condenccpp::TypoPolicy* tp);
  private:
  const ::condenccpp::TypoPolicy& _internal_tp() const;
  ::condenccpp::TypoPolicy* _internal_mutable_tp();
  public:
  void unsafe_arena_set_allocated_tp(
      ::condenccpp::TypoPolicy* tp);
  ::condenccpp::TypoPolicy* unsafe_arena_release_tp();

  // optional int32 period_for_sending_log = 2 [default = 21600];
  bool has_period_for_sending_log() const;
  private:
  bool _internal_has_period_for_sending_log() const;
  public:
  void clear_period_for_sending_log();
  int32_t period_for_sending_log() const;
  void set_period_for_sending_log(int32_t value);
  private:
  int32_t _internal_period_for_sending_log() const;
  void _internal_set_period_for_sending_log(int32_t value);
  public:

  // optional bool allowed_typo_login = 1 [default = true];
  bool has_allowed_typo_login() const;
  private:
  bool _internal_has_allowed_typo_login() const;
  public:
  void clear_allowed_typo_login();
  bool allowed_typo_login() const;
  void set_allowed_typo_login(bool value);
  private:
  bool _internal_allowed_typo_login() const;
  void _internal_set_allowed_typo_login(bool value);
  public:

  // optional bool expire_typos = 3 [default = true];
  bool has_expire_typos() const;
  private:
  bool _internal_has_expire_typos() const;
  public:
  void clear_expire_typos();
  bool expire_typos() const;
  void set_expire_typos(bool value);
  private:
  bool _internal_expire_typos() const;
  void _internal_set_expire_typos(bool value);
  public:

  // optional bool allow_upload = 5 [default = true];
  bool has_allow_upload() const;
  private:
  bool _internal_has_allow_upload() const;
  public:
  void clear_allow_upload();
  bool allow_upload() const;
  void set_allow_upload(bool value);
  private:
  bool _internal_allow_upload() const;
  void _internal_set_allow_upload(bool value);
  public:

  // optional int64 typo_expiry_time = 4 [default = 2592000];
  bool has_typo_expiry_time() const;
  private:
  bool _internal_has_typo_expiry_time() const;
  public:
  void clear_typo_expiry_time();
  int64_t typo_expiry_time() const;
  void set_typo_expiry_time(int64_t value);
  private:
  int64_t _internal_typo_expiry_time() const;
  void _internal_set_typo_expiry_time(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:condenccpp.ConfigHeader)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr install_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr global_salt_;
    ::condenccpp::TypoPolicy* tp_;
    int32_t period_for_sending_log_;
    bool allowed_typo_login_;
    bool expire_typos_;
    bool allow_upload_;
    int64_t typo_expiry_time_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class EncHeaderData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:condenccpp.EncHeaderData) */ {
 public:
  inline EncHeaderData() : EncHeaderData(nullptr) {}
  ~EncHeaderData() override;
  explicit PROTOBUF_CONSTEXPR EncHeaderData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EncHeaderData(const EncHeaderData& from);
  EncHeaderData(EncHeaderData&& from) noexcept
    : EncHeaderData() {
    *this = ::std::move(from);
  }

  inline EncHeaderData& operator=(const EncHeaderData& from) {
    CopyFrom(from);
    return *this;
  }
  inline EncHeaderData& operator=(EncHeaderData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EncHeaderData& default_instance() {
    return *internal_default_instance();
  }
  static inline const EncHeaderData* internal_default_instance() {
    return reinterpret_cast<const EncHeaderData*>(
               &_EncHeaderData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(EncHeaderData& a, EncHeaderData& b) {
    a.Swap(&b);
  }
  inline void Swap(EncHeaderData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EncHeaderData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EncHeaderData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EncHeaderData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EncHeaderData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EncHeaderData& from) {
    EncHeaderData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EncHeaderData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "condenccpp.EncHeaderData";
  }
  protected:
  explicit EncHeaderData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFreqFieldNumber = 2,
    kLastUsedFieldNumber = 3,
    kPwFieldNumber = 1,
    kPwEntFieldNumber = 4,
  };
  // repeated int32 freq = 2;
  int freq_size() const;
  private:
  int _internal_freq_size() const;
  public:
  void clear_freq();
  private:
  int32_t _internal_freq(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_freq() const;
  void _internal_add_freq(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_freq();
  public:
  int32_t freq(int index) const;
  void set_freq(int index, int32_t value);
  void add_freq(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      freq() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_freq();

  // repeated int64 last_used = 3;
  int last_used_size() const;
  private:
  int _internal_last_used_size() const;
  public:
  void clear_last_used();
  private:
  int64_t _internal_last_used(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_last_used() const;
  void _internal_add_last_used(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_last_used();
  public:
  int64_t last_used(int index) const;
  void set_last_used(int index, int64_t value);
  void add_last_used(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      last_used() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_last_used();

  // required bytes pw = 1;
  bool has_pw() const;
  private:
  bool _internal_has_pw() const;
  public:
  void clear_pw();
  const std::string& pw() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pw(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pw();
  PROTOBUF_NODISCARD std::string* release_pw();
  void set_allocated_pw(std::string* pw);
  private:
  const std::string& _internal_pw() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pw(const std::string& value);
  std::string* _internal_mutable_pw();
  public:

  // required float pw_ent = 4;
  bool has_pw_ent() const;
  private:
  bool _internal_has_pw_ent() const;
  public:
  void clear_pw_ent();
  float pw_ent() const;
  void set_pw_ent(float value);
  private:
  float _internal_pw_ent() const;
  void _internal_set_pw_ent(float value);
  public:

  // @@protoc_insertion_point(class_scope:condenccpp.EncHeaderData)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > freq_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > last_used_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pw_;
    float pw_ent_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class Header final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:condenccpp.Header) */ {
 public:
  inline Header() : Header(nullptr) {}
  ~Header() override;
  explicit PROTOBUF_CONSTEXPR Header(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Header(const Header& from);
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  inline Header& operator=(Header&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Header& default_instance() {
    return *internal_default_instance();
  }
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }
  inline void Swap(Header* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Header* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Header* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Header>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Header& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Header& from) {
    Header::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Header* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "condenccpp.Header";
  }
  protected:
  explicit Header(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEncHeaderFieldNumber = 5,
    kIndexjFieldNumber = 1,
    kLastLogSentTimeFieldNumber = 2,
    kLoginCountFieldNumber = 3,
    kSysStateFieldNumber = 4,
  };
  // required bytes enc_header = 5;
  bool has_enc_header() const;
  private:
  bool _internal_has_enc_header() const;
  public:
  void clear_enc_header();
  const std::string& enc_header() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_enc_header(ArgT0&& arg0, ArgT... args);
  std::string* mutable_enc_header();
  PROTOBUF_NODISCARD std::string* release_enc_header();
  void set_allocated_enc_header(std::string* enc_header);
  private:
  const std::string& _internal_enc_header() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_enc_header(const std::string& value);
  std::string* _internal_mutable_enc_header();
  public:

  // optional int32 indexj = 1 [default = 0];
  bool has_indexj() const;
  private:
  bool _internal_has_indexj() const;
  public:
  void clear_indexj();
  int32_t indexj() const;
  void set_indexj(int32_t value);
  private:
  int32_t _internal_indexj() const;
  void _internal_set_indexj(int32_t value);
  public:

  // optional int32 last_log_sent_time = 2 [default = 0];
  bool has_last_log_sent_time() const;
  private:
  bool _internal_has_last_log_sent_time() const;
  public:
  void clear_last_log_sent_time();
  int32_t last_log_sent_time() const;
  void set_last_log_sent_time(int32_t value);
  private:
  int32_t _internal_last_log_sent_time() const;
  void _internal_set_last_log_sent_time(int32_t value);
  public:

  // optional int32 login_count = 3 [default = 0];
  bool has_login_count() const;
  private:
  bool _internal_has_login_count() const;
  public:
  void clear_login_count();
  int32_t login_count() const;
  void set_login_count(int32_t value);
  private:
  int32_t _internal_login_count() const;
  void _internal_set_login_count(int32_t value);
  public:

  // optional .condenccpp.SystemStatus sys_state = 4 [default = UNINITIALIZED];
  bool has_sys_state() const;
  private:
  bool _internal_has_sys_state() const;
  public:
  void clear_sys_state();
  ::condenccpp::SystemStatus sys_state() const;
  void set_sys_state(::condenccpp::SystemStatus value);
  private:
  ::condenccpp::SystemStatus _internal_sys_state() const;
  void _internal_set_sys_state(::condenccpp::SystemStatus value);
  public:

  // @@protoc_insertion_point(class_scope:condenccpp.Header)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enc_header_;
    int32_t indexj_;
    int32_t last_log_sent_time_;
    int32_t login_count_;
    int sys_state_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class Logs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:condenccpp.Logs) */ {
 public:
  inline Logs() : Logs(nullptr) {}
  ~Logs() override;
  explicit PROTOBUF_CONSTEXPR Logs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Logs(const Logs& from);
  Logs(Logs&& from) noexcept
    : Logs() {
    *this = ::std::move(from);
  }

  inline Logs& operator=(const Logs& from) {
    CopyFrom(from);
    return *this;
  }
  inline Logs& operator=(Logs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Logs& default_instance() {
    return *internal_default_instance();
  }
  static inline const Logs* internal_default_instance() {
    return reinterpret_cast<const Logs*>(
               &_Logs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Logs& a, Logs& b) {
    a.Swap(&b);
  }
  inline void Swap(Logs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Logs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Logs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Logs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Logs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Logs& from) {
    Logs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Logs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "condenccpp.Logs";
  }
  protected:
  explicit Logs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLFieldNumber = 1,
    kTyposFieldNumber = 2,
    kTyposSavedFieldNumber = 3,
  };
  // repeated .condenccpp.Log L = 1;
  int l_size() const;
  private:
  int _internal_l_size() const;
  public:
  void clear_l();
  ::condenccpp::Log* mutable_l(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::condenccpp::Log >*
      mutable_l();
  private:
  const ::condenccpp::Log& _internal_l(int index) const;
  ::condenccpp::Log* _internal_add_l();
  public:
  const ::condenccpp::Log& l(int index) const;
  ::condenccpp::Log* add_l();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::condenccpp::Log >&
      l() const;

  // optional int32 typos = 2 [default = 0];
  bool has_typos() const;
  private:
  bool _internal_has_typos() const;
  public:
  void clear_typos();
  int32_t typos() const;
  void set_typos(int32_t value);
  private:
  int32_t _internal_typos() const;
  void _internal_set_typos(int32_t value);
  public:

  // optional int32 typos_saved = 3 [default = 0];
  bool has_typos_saved() const;
  private:
  bool _internal_has_typos_saved() const;
  public:
  void clear_typos_saved();
  int32_t typos_saved() const;
  void set_typos_saved(int32_t value);
  private:
  int32_t _internal_typos_saved() const;
  void _internal_set_typos_saved(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:condenccpp.Logs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::condenccpp::Log > l_;
    int32_t typos_;
    int32_t typos_saved_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class typoDB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:condenccpp.typoDB) */ {
 public:
  inline typoDB() : typoDB(nullptr) {}
  ~typoDB() override;
  explicit PROTOBUF_CONSTEXPR typoDB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  typoDB(const typoDB& from);
  typoDB(typoDB&& from) noexcept
    : typoDB() {
    *this = ::std::move(from);
  }

  inline typoDB& operator=(const typoDB& from) {
    CopyFrom(from);
    return *this;
  }
  inline typoDB& operator=(typoDB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const typoDB& default_instance() {
    return *internal_default_instance();
  }
  static inline const typoDB* internal_default_instance() {
    return reinterpret_cast<const typoDB*>(
               &_typoDB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(typoDB& a, typoDB& b) {
    a.Swap(&b);
  }
  inline void Swap(typoDB* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(typoDB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  typoDB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<typoDB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const typoDB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const typoDB& from) {
    typoDB::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(typoDB* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "condenccpp.typoDB";
  }
  protected:
  explicit typoDB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWFieldNumber = 3,
    kTFieldNumber = 4,
    kRlpwdctxorencFieldNumber = 6,
    kVersionFieldNumber = 9,
    kCHFieldNumber = 1,
    kHFieldNumber = 2,
    kLogsFieldNumber = 5,
  };
  // repeated bytes W = 3;
  int w_size() const;
  private:
  int _internal_w_size() const;
  public:
  void clear_w();
  const std::string& w(int index) const;
  std::string* mutable_w(int index);
  void set_w(int index, const std::string& value);
  void set_w(int index, std::string&& value);
  void set_w(int index, const char* value);
  void set_w(int index, const void* value, size_t size);
  std::string* add_w();
  void add_w(const std::string& value);
  void add_w(std::string&& value);
  void add_w(const char* value);
  void add_w(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& w() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_w();
  private:
  const std::string& _internal_w(int index) const;
  std::string* _internal_add_w();
  public:

  // repeated bytes T = 4;
  int t_size() const;
  private:
  int _internal_t_size() const;
  public:
  void clear_t();
  const std::string& t(int index) const;
  std::string* mutable_t(int index);
  void set_t(int index, const std::string& value);
  void set_t(int index, std::string&& value);
  void set_t(int index, const char* value);
  void set_t(int index, const void* value, size_t size);
  std::string* add_t();
  void add_t(const std::string& value);
  void add_t(std::string&& value);
  void add_t(const char* value);
  void add_t(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& t() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_t();
  private:
  const std::string& _internal_t(int index) const;
  std::string* _internal_add_t();
  public:

  // required bytes rlpwdctxorenc = 6;
  bool has_rlpwdctxorenc() const;
  private:
  bool _internal_has_rlpwdctxorenc() const;
  public:
  void clear_rlpwdctxorenc();
  const std::string& rlpwdctxorenc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rlpwdctxorenc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rlpwdctxorenc();
  PROTOBUF_NODISCARD std::string* release_rlpwdctxorenc();
  void set_allocated_rlpwdctxorenc(std::string* rlpwdctxorenc);
  private:
  const std::string& _internal_rlpwdctxorenc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rlpwdctxorenc(const std::string& value);
  std::string* _internal_mutable_rlpwdctxorenc();
  public:

  // optional string version = 9 [default = "1"];
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // required .condenccpp.ConfigHeader CH = 1;
  bool has_ch() const;
  private:
  bool _internal_has_ch() const;
  public:
  void clear_ch();
  const ::condenccpp::ConfigHeader& ch() const;
  PROTOBUF_NODISCARD ::condenccpp::ConfigHeader* release_ch();
  ::condenccpp::ConfigHeader* mutable_ch();
  void set_allocated_ch(::condenccpp::ConfigHeader* ch);
  private:
  const ::condenccpp::ConfigHeader& _internal_ch() const;
  ::condenccpp::ConfigHeader* _internal_mutable_ch();
  public:
  void unsafe_arena_set_allocated_ch(
      ::condenccpp::ConfigHeader* ch);
  ::condenccpp::ConfigHeader* unsafe_arena_release_ch();

  // required .condenccpp.Header H = 2;
  bool has_h() const;
  private:
  bool _internal_has_h() const;
  public:
  void clear_h();
  const ::condenccpp::Header& h() const;
  PROTOBUF_NODISCARD ::condenccpp::Header* release_h();
  ::condenccpp::Header* mutable_h();
  void set_allocated_h(::condenccpp::Header* h);
  private:
  const ::condenccpp::Header& _internal_h() const;
  ::condenccpp::Header* _internal_mutable_h();
  public:
  void unsafe_arena_set_allocated_h(
      ::condenccpp::Header* h);
  ::condenccpp::Header* unsafe_arena_release_h();

  // optional .condenccpp.Logs logs = 5;
  bool has_logs() const;
  private:
  bool _internal_has_logs() const;
  public:
  void clear_logs();
  const ::condenccpp::Logs& logs() const;
  PROTOBUF_NODISCARD ::condenccpp::Logs* release_logs();
  ::condenccpp::Logs* mutable_logs();
  void set_allocated_logs(::condenccpp::Logs* logs);
  private:
  const ::condenccpp::Logs& _internal_logs() const;
  ::condenccpp::Logs* _internal_mutable_logs();
  public:
  void unsafe_arena_set_allocated_logs(
      ::condenccpp::Logs* logs);
  ::condenccpp::Logs* unsafe_arena_release_logs();

  // @@protoc_insertion_point(class_scope:condenccpp.typoDB)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> w_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> t_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rlpwdctxorenc_;
    static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::condenccpp::ConfigHeader* ch_;
    ::condenccpp::Header* h_;
    ::condenccpp::Logs* logs_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class WaitlistEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:condenccpp.WaitlistEntry) */ {
 public:
  inline WaitlistEntry() : WaitlistEntry(nullptr) {}
  ~WaitlistEntry() override;
  explicit PROTOBUF_CONSTEXPR WaitlistEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WaitlistEntry(const WaitlistEntry& from);
  WaitlistEntry(WaitlistEntry&& from) noexcept
    : WaitlistEntry() {
    *this = ::std::move(from);
  }

  inline WaitlistEntry& operator=(const WaitlistEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline WaitlistEntry& operator=(WaitlistEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WaitlistEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const WaitlistEntry* internal_default_instance() {
    return reinterpret_cast<const WaitlistEntry*>(
               &_WaitlistEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(WaitlistEntry& a, WaitlistEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(WaitlistEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WaitlistEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WaitlistEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WaitlistEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WaitlistEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WaitlistEntry& from) {
    WaitlistEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WaitlistEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "condenccpp.WaitlistEntry";
  }
  protected:
  explicit WaitlistEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPwFieldNumber = 1,
    kTsFieldNumber = 2,
  };
  // required bytes pw = 1;
  bool has_pw() const;
  private:
  bool _internal_has_pw() const;
  public:
  void clear_pw();
  const std::string& pw() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pw(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pw();
  PROTOBUF_NODISCARD std::string* release_pw();
  void set_allocated_pw(std::string* pw);
  private:
  const std::string& _internal_pw() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pw(const std::string& value);
  std::string* _internal_mutable_pw();
  public:

  // required int64 ts = 2 [default = -1];
  bool has_ts() const;
  private:
  bool _internal_has_ts() const;
  public:
  void clear_ts();
  int64_t ts() const;
  void set_ts(int64_t value);
  private:
  int64_t _internal_ts() const;
  void _internal_set_ts(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:condenccpp.WaitlistEntry)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pw_;
    int64_t ts_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class PwdCtxORPredicate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:condenccpp.PwdCtxORPredicate) */ {
 public:
  inline PwdCtxORPredicate() : PwdCtxORPredicate(nullptr) {}
  ~PwdCtxORPredicate() override;
  explicit PROTOBUF_CONSTEXPR PwdCtxORPredicate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PwdCtxORPredicate(const PwdCtxORPredicate& from);
  PwdCtxORPredicate(PwdCtxORPredicate&& from) noexcept
    : PwdCtxORPredicate() {
    *this = ::std::move(from);
  }

  inline PwdCtxORPredicate& operator=(const PwdCtxORPredicate& from) {
    CopyFrom(from);
    return *this;
  }
  inline PwdCtxORPredicate& operator=(PwdCtxORPredicate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PwdCtxORPredicate& default_instance() {
    return *internal_default_instance();
  }
  static inline const PwdCtxORPredicate* internal_default_instance() {
    return reinterpret_cast<const PwdCtxORPredicate*>(
               &_PwdCtxORPredicate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PwdCtxORPredicate& a, PwdCtxORPredicate& b) {
    a.Swap(&b);
  }
  inline void Swap(PwdCtxORPredicate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PwdCtxORPredicate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PwdCtxORPredicate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PwdCtxORPredicate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PwdCtxORPredicate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PwdCtxORPredicate& from) {
    PwdCtxORPredicate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PwdCtxORPredicate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "condenccpp.PwdCtxORPredicate";
  }
  protected:
  explicit PwdCtxORPredicate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRlpwdctxFieldNumber = 1,
    kRlpwdctxorencFieldNumber = 2,
    kRlpwdctxorcencFieldNumber = 3,
  };
  // optional string rlpwdctx = 1;
  bool has_rlpwdctx() const;
  private:
  bool _internal_has_rlpwdctx() const;
  public:
  void clear_rlpwdctx();
  const std::string& rlpwdctx() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rlpwdctx(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rlpwdctx();
  PROTOBUF_NODISCARD std::string* release_rlpwdctx();
  void set_allocated_rlpwdctx(std::string* rlpwdctx);
  private:
  const std::string& _internal_rlpwdctx() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rlpwdctx(const std::string& value);
  std::string* _internal_mutable_rlpwdctx();
  public:

  // optional string rlpwdctxorenc = 2;
  bool has_rlpwdctxorenc() const;
  private:
  bool _internal_has_rlpwdctxorenc() const;
  public:
  void clear_rlpwdctxorenc();
  const std::string& rlpwdctxorenc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rlpwdctxorenc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rlpwdctxorenc();
  PROTOBUF_NODISCARD std::string* release_rlpwdctxorenc();
  void set_allocated_rlpwdctxorenc(std::string* rlpwdctxorenc);
  private:
  const std::string& _internal_rlpwdctxorenc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rlpwdctxorenc(const std::string& value);
  std::string* _internal_mutable_rlpwdctxorenc();
  public:

  // optional string rlpwdctxorcenc = 3;
  bool has_rlpwdctxorcenc() const;
  private:
  bool _internal_has_rlpwdctxorcenc() const;
  public:
  void clear_rlpwdctxorcenc();
  const std::string& rlpwdctxorcenc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rlpwdctxorcenc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rlpwdctxorcenc();
  PROTOBUF_NODISCARD std::string* release_rlpwdctxorcenc();
  void set_allocated_rlpwdctxorcenc(std::string* rlpwdctxorcenc);
  private:
  const std::string& _internal_rlpwdctxorcenc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rlpwdctxorcenc(const std::string& value);
  std::string* _internal_mutable_rlpwdctxorcenc();
  public:

  // @@protoc_insertion_point(class_scope:condenccpp.PwdCtxORPredicate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rlpwdctx_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rlpwdctxorenc_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rlpwdctxorcenc_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class PaillierPK final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:condenccpp.PaillierPK) */ {
 public:
  inline PaillierPK() : PaillierPK(nullptr) {}
  ~PaillierPK() override;
  explicit PROTOBUF_CONSTEXPR PaillierPK(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PaillierPK(const PaillierPK& from);
  PaillierPK(PaillierPK&& from) noexcept
    : PaillierPK() {
    *this = ::std::move(from);
  }

  inline PaillierPK& operator=(const PaillierPK& from) {
    CopyFrom(from);
    return *this;
  }
  inline PaillierPK& operator=(PaillierPK&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PaillierPK& default_instance() {
    return *internal_default_instance();
  }
  static inline const PaillierPK* internal_default_instance() {
    return reinterpret_cast<const PaillierPK*>(
               &_PaillierPK_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PaillierPK& a, PaillierPK& b) {
    a.Swap(&b);
  }
  inline void Swap(PaillierPK* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PaillierPK* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PaillierPK* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PaillierPK>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PaillierPK& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PaillierPK& from) {
    PaillierPK::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PaillierPK* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "condenccpp.PaillierPK";
  }
  protected:
  explicit PaillierPK(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPailPKFieldNumber = 1,
    kPailSkFieldNumber = 2,
  };
  // optional bytes Pail_PK = 1;
  bool has_pail_pk() const;
  private:
  bool _internal_has_pail_pk() const;
  public:
  void clear_pail_pk();
  const std::string& pail_pk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pail_pk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pail_pk();
  PROTOBUF_NODISCARD std::string* release_pail_pk();
  void set_allocated_pail_pk(std::string* pail_pk);
  private:
  const std::string& _internal_pail_pk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pail_pk(const std::string& value);
  std::string* _internal_mutable_pail_pk();
  public:

  // optional bytes Pail_Sk = 2;
  bool has_pail_sk() const;
  private:
  bool _internal_has_pail_sk() const;
  public:
  void clear_pail_sk();
  const std::string& pail_sk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pail_sk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pail_sk();
  PROTOBUF_NODISCARD std::string* release_pail_sk();
  void set_allocated_pail_sk(std::string* pail_sk);
  private:
  const std::string& _internal_pail_sk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pail_sk(const std::string& value);
  std::string* _internal_mutable_pail_sk();
  public:

  // @@protoc_insertion_point(class_scope:condenccpp.PaillierPK)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pail_pk_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pail_sk_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TypoPolicy

// optional int32 edit_cutoff = 1 [default = 1];
inline bool TypoPolicy::_internal_has_edit_cutoff() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TypoPolicy::has_edit_cutoff() const {
  return _internal_has_edit_cutoff();
}
inline void TypoPolicy::clear_edit_cutoff() {
  _impl_.edit_cutoff_ = 1;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t TypoPolicy::_internal_edit_cutoff() const {
  return _impl_.edit_cutoff_;
}
inline int32_t TypoPolicy::edit_cutoff() const {
  // @@protoc_insertion_point(field_get:condenccpp.TypoPolicy.edit_cutoff)
  return _internal_edit_cutoff();
}
inline void TypoPolicy::_internal_set_edit_cutoff(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.edit_cutoff_ = value;
}
inline void TypoPolicy::set_edit_cutoff(int32_t value) {
  _internal_set_edit_cutoff(value);
  // @@protoc_insertion_point(field_set:condenccpp.TypoPolicy.edit_cutoff)
}

// optional int32 abs_entcutoff = 2 [default = 10];
inline bool TypoPolicy::_internal_has_abs_entcutoff() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TypoPolicy::has_abs_entcutoff() const {
  return _internal_has_abs_entcutoff();
}
inline void TypoPolicy::clear_abs_entcutoff() {
  _impl_.abs_entcutoff_ = 10;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t TypoPolicy::_internal_abs_entcutoff() const {
  return _impl_.abs_entcutoff_;
}
inline int32_t TypoPolicy::abs_entcutoff() const {
  // @@protoc_insertion_point(field_get:condenccpp.TypoPolicy.abs_entcutoff)
  return _internal_abs_entcutoff();
}
inline void TypoPolicy::_internal_set_abs_entcutoff(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.abs_entcutoff_ = value;
}
inline void TypoPolicy::set_abs_entcutoff(int32_t value) {
  _internal_set_abs_entcutoff(value);
  // @@protoc_insertion_point(field_set:condenccpp.TypoPolicy.abs_entcutoff)
}

// optional int32 rel_entcutoff = 3 [default = 3];
inline bool TypoPolicy::_internal_has_rel_entcutoff() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TypoPolicy::has_rel_entcutoff() const {
  return _internal_has_rel_entcutoff();
}
inline void TypoPolicy::clear_rel_entcutoff() {
  _impl_.rel_entcutoff_ = 3;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t TypoPolicy::_internal_rel_entcutoff() const {
  return _impl_.rel_entcutoff_;
}
inline int32_t TypoPolicy::rel_entcutoff() const {
  // @@protoc_insertion_point(field_get:condenccpp.TypoPolicy.rel_entcutoff)
  return _internal_rel_entcutoff();
}
inline void TypoPolicy::_internal_set_rel_entcutoff(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.rel_entcutoff_ = value;
}
inline void TypoPolicy::set_rel_entcutoff(int32_t value) {
  _internal_set_rel_entcutoff(value);
  // @@protoc_insertion_point(field_set:condenccpp.TypoPolicy.rel_entcutoff)
}

// optional int32 min_length = 4 [default = 6];
inline bool TypoPolicy::_internal_has_min_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TypoPolicy::has_min_length() const {
  return _internal_has_min_length();
}
inline void TypoPolicy::clear_min_length() {
  _impl_.min_length_ = 6;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t TypoPolicy::_internal_min_length() const {
  return _impl_.min_length_;
}
inline int32_t TypoPolicy::min_length() const {
  // @@protoc_insertion_point(field_get:condenccpp.TypoPolicy.min_length)
  return _internal_min_length();
}
inline void TypoPolicy::_internal_set_min_length(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.min_length_ = value;
}
inline void TypoPolicy::set_min_length(int32_t value) {
  _internal_set_min_length(value);
  // @@protoc_insertion_point(field_set:condenccpp.TypoPolicy.min_length)
}

// -------------------------------------------------------------------

// Log

// required bool in_cache = 1;
inline bool Log::_internal_has_in_cache() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Log::has_in_cache() const {
  return _internal_has_in_cache();
}
inline void Log::clear_in_cache() {
  _impl_.in_cache_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool Log::_internal_in_cache() const {
  return _impl_.in_cache_;
}
inline bool Log::in_cache() const {
  // @@protoc_insertion_point(field_get:condenccpp.Log.in_cache)
  return _internal_in_cache();
}
inline void Log::_internal_set_in_cache(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.in_cache_ = value;
}
inline void Log::set_in_cache(bool value) {
  _internal_set_in_cache(value);
  // @@protoc_insertion_point(field_set:condenccpp.Log.in_cache)
}

// required bool istop5fixable = 2;
inline bool Log::_internal_has_istop5fixable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Log::has_istop5fixable() const {
  return _internal_has_istop5fixable();
}
inline void Log::clear_istop5fixable() {
  _impl_.istop5fixable_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool Log::_internal_istop5fixable() const {
  return _impl_.istop5fixable_;
}
inline bool Log::istop5fixable() const {
  // @@protoc_insertion_point(field_get:condenccpp.Log.istop5fixable)
  return _internal_istop5fixable();
}
inline void Log::_internal_set_istop5fixable(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.istop5fixable_ = value;
}
inline void Log::set_istop5fixable(bool value) {
  _internal_set_istop5fixable(value);
  // @@protoc_insertion_point(field_set:condenccpp.Log.istop5fixable)
}

// required int32 edit_dist = 3;
inline bool Log::_internal_has_edit_dist() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Log::has_edit_dist() const {
  return _internal_has_edit_dist();
}
inline void Log::clear_edit_dist() {
  _impl_.edit_dist_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t Log::_internal_edit_dist() const {
  return _impl_.edit_dist_;
}
inline int32_t Log::edit_dist() const {
  // @@protoc_insertion_point(field_get:condenccpp.Log.edit_dist)
  return _internal_edit_dist();
}
inline void Log::_internal_set_edit_dist(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.edit_dist_ = value;
}
inline void Log::set_edit_dist(int32_t value) {
  _internal_set_edit_dist(value);
  // @@protoc_insertion_point(field_set:condenccpp.Log.edit_dist)
}

// required float rel_entropy = 4;
inline bool Log::_internal_has_rel_entropy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Log::has_rel_entropy() const {
  return _internal_has_rel_entropy();
}
inline void Log::clear_rel_entropy() {
  _impl_.rel_entropy_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float Log::_internal_rel_entropy() const {
  return _impl_.rel_entropy_;
}
inline float Log::rel_entropy() const {
  // @@protoc_insertion_point(field_get:condenccpp.Log.rel_entropy)
  return _internal_rel_entropy();
}
inline void Log::_internal_set_rel_entropy(float value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.rel_entropy_ = value;
}
inline void Log::set_rel_entropy(float value) {
  _internal_set_rel_entropy(value);
  // @@protoc_insertion_point(field_set:condenccpp.Log.rel_entropy)
}

// required float pass_complexity = 5;
inline bool Log::_internal_has_pass_complexity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Log::has_pass_complexity() const {
  return _internal_has_pass_complexity();
}
inline void Log::clear_pass_complexity() {
  _impl_.pass_complexity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float Log::_internal_pass_complexity() const {
  return _impl_.pass_complexity_;
}
inline float Log::pass_complexity() const {
  // @@protoc_insertion_point(field_get:condenccpp.Log.pass_complexity)
  return _internal_pass_complexity();
}
inline void Log::_internal_set_pass_complexity(float value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.pass_complexity_ = value;
}
inline void Log::set_pass_complexity(float value) {
  _internal_set_pass_complexity(value);
  // @@protoc_insertion_point(field_set:condenccpp.Log.pass_complexity)
}

// required uint32 tid = 6;
inline bool Log::_internal_has_tid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Log::has_tid() const {
  return _internal_has_tid();
}
inline void Log::clear_tid() {
  _impl_.tid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t Log::_internal_tid() const {
  return _impl_.tid_;
}
inline uint32_t Log::tid() const {
  // @@protoc_insertion_point(field_get:condenccpp.Log.tid)
  return _internal_tid();
}
inline void Log::_internal_set_tid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.tid_ = value;
}
inline void Log::set_tid(uint32_t value) {
  _internal_set_tid(value);
  // @@protoc_insertion_point(field_set:condenccpp.Log.tid)
}

// required int64 ts = 7;
inline bool Log::_internal_has_ts() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Log::has_ts() const {
  return _internal_has_ts();
}
inline void Log::clear_ts() {
  _impl_.ts_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int64_t Log::_internal_ts() const {
  return _impl_.ts_;
}
inline int64_t Log::ts() const {
  // @@protoc_insertion_point(field_get:condenccpp.Log.ts)
  return _internal_ts();
}
inline void Log::_internal_set_ts(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.ts_ = value;
}
inline void Log::set_ts(int64_t value) {
  _internal_set_ts(value);
  // @@protoc_insertion_point(field_set:condenccpp.Log.ts)
}

// required string localtime = 8;
inline bool Log::_internal_has_localtime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Log::has_localtime() const {
  return _internal_has_localtime();
}
inline void Log::clear_localtime() {
  _impl_.localtime_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Log::localtime() const {
  // @@protoc_insertion_point(field_get:condenccpp.Log.localtime)
  return _internal_localtime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Log::set_localtime(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.localtime_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:condenccpp.Log.localtime)
}
inline std::string* Log::mutable_localtime() {
  std::string* _s = _internal_mutable_localtime();
  // @@protoc_insertion_point(field_mutable:condenccpp.Log.localtime)
  return _s;
}
inline const std::string& Log::_internal_localtime() const {
  return _impl_.localtime_.Get();
}
inline void Log::_internal_set_localtime(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.localtime_.Set(value, GetArenaForAllocation());
}
inline std::string* Log::_internal_mutable_localtime() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.localtime_.Mutable(GetArenaForAllocation());
}
inline std::string* Log::release_localtime() {
  // @@protoc_insertion_point(field_release:condenccpp.Log.localtime)
  if (!_internal_has_localtime()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.localtime_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.localtime_.IsDefault()) {
    _impl_.localtime_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Log::set_allocated_localtime(std::string* localtime) {
  if (localtime != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.localtime_.SetAllocated(localtime, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.localtime_.IsDefault()) {
    _impl_.localtime_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:condenccpp.Log.localtime)
}

// -------------------------------------------------------------------

// ConfigHeader

// optional bool allowed_typo_login = 1 [default = true];
inline bool ConfigHeader::_internal_has_allowed_typo_login() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ConfigHeader::has_allowed_typo_login() const {
  return _internal_has_allowed_typo_login();
}
inline void ConfigHeader::clear_allowed_typo_login() {
  _impl_.allowed_typo_login_ = true;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool ConfigHeader::_internal_allowed_typo_login() const {
  return _impl_.allowed_typo_login_;
}
inline bool ConfigHeader::allowed_typo_login() const {
  // @@protoc_insertion_point(field_get:condenccpp.ConfigHeader.allowed_typo_login)
  return _internal_allowed_typo_login();
}
inline void ConfigHeader::_internal_set_allowed_typo_login(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.allowed_typo_login_ = value;
}
inline void ConfigHeader::set_allowed_typo_login(bool value) {
  _internal_set_allowed_typo_login(value);
  // @@protoc_insertion_point(field_set:condenccpp.ConfigHeader.allowed_typo_login)
}

// optional int32 period_for_sending_log = 2 [default = 21600];
inline bool ConfigHeader::_internal_has_period_for_sending_log() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ConfigHeader::has_period_for_sending_log() const {
  return _internal_has_period_for_sending_log();
}
inline void ConfigHeader::clear_period_for_sending_log() {
  _impl_.period_for_sending_log_ = 21600;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t ConfigHeader::_internal_period_for_sending_log() const {
  return _impl_.period_for_sending_log_;
}
inline int32_t ConfigHeader::period_for_sending_log() const {
  // @@protoc_insertion_point(field_get:condenccpp.ConfigHeader.period_for_sending_log)
  return _internal_period_for_sending_log();
}
inline void ConfigHeader::_internal_set_period_for_sending_log(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.period_for_sending_log_ = value;
}
inline void ConfigHeader::set_period_for_sending_log(int32_t value) {
  _internal_set_period_for_sending_log(value);
  // @@protoc_insertion_point(field_set:condenccpp.ConfigHeader.period_for_sending_log)
}

// optional bool expire_typos = 3 [default = true];
inline bool ConfigHeader::_internal_has_expire_typos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ConfigHeader::has_expire_typos() const {
  return _internal_has_expire_typos();
}
inline void ConfigHeader::clear_expire_typos() {
  _impl_.expire_typos_ = true;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool ConfigHeader::_internal_expire_typos() const {
  return _impl_.expire_typos_;
}
inline bool ConfigHeader::expire_typos() const {
  // @@protoc_insertion_point(field_get:condenccpp.ConfigHeader.expire_typos)
  return _internal_expire_typos();
}
inline void ConfigHeader::_internal_set_expire_typos(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.expire_typos_ = value;
}
inline void ConfigHeader::set_expire_typos(bool value) {
  _internal_set_expire_typos(value);
  // @@protoc_insertion_point(field_set:condenccpp.ConfigHeader.expire_typos)
}

// optional int64 typo_expiry_time = 4 [default = 2592000];
inline bool ConfigHeader::_internal_has_typo_expiry_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ConfigHeader::has_typo_expiry_time() const {
  return _internal_has_typo_expiry_time();
}
inline void ConfigHeader::clear_typo_expiry_time() {
  _impl_.typo_expiry_time_ = int64_t{2592000};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int64_t ConfigHeader::_internal_typo_expiry_time() const {
  return _impl_.typo_expiry_time_;
}
inline int64_t ConfigHeader::typo_expiry_time() const {
  // @@protoc_insertion_point(field_get:condenccpp.ConfigHeader.typo_expiry_time)
  return _internal_typo_expiry_time();
}
inline void ConfigHeader::_internal_set_typo_expiry_time(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.typo_expiry_time_ = value;
}
inline void ConfigHeader::set_typo_expiry_time(int64_t value) {
  _internal_set_typo_expiry_time(value);
  // @@protoc_insertion_point(field_set:condenccpp.ConfigHeader.typo_expiry_time)
}

// optional bool allow_upload = 5 [default = true];
inline bool ConfigHeader::_internal_has_allow_upload() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ConfigHeader::has_allow_upload() const {
  return _internal_has_allow_upload();
}
inline void ConfigHeader::clear_allow_upload() {
  _impl_.allow_upload_ = true;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool ConfigHeader::_internal_allow_upload() const {
  return _impl_.allow_upload_;
}
inline bool ConfigHeader::allow_upload() const {
  // @@protoc_insertion_point(field_get:condenccpp.ConfigHeader.allow_upload)
  return _internal_allow_upload();
}
inline void ConfigHeader::_internal_set_allow_upload(bool value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.allow_upload_ = value;
}
inline void ConfigHeader::set_allow_upload(bool value) {
  _internal_set_allow_upload(value);
  // @@protoc_insertion_point(field_set:condenccpp.ConfigHeader.allow_upload)
}

// optional .condenccpp.TypoPolicy tp = 6;
inline bool ConfigHeader::_internal_has_tp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tp_ != nullptr);
  return value;
}
inline bool ConfigHeader::has_tp() const {
  return _internal_has_tp();
}
inline void ConfigHeader::clear_tp() {
  if (_impl_.tp_ != nullptr) _impl_.tp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::condenccpp::TypoPolicy& ConfigHeader::_internal_tp() const {
  const ::condenccpp::TypoPolicy* p = _impl_.tp_;
  return p != nullptr ? *p : reinterpret_cast<const ::condenccpp::TypoPolicy&>(
      ::condenccpp::_TypoPolicy_default_instance_);
}
inline const ::condenccpp::TypoPolicy& ConfigHeader::tp() const {
  // @@protoc_insertion_point(field_get:condenccpp.ConfigHeader.tp)
  return _internal_tp();
}
inline void ConfigHeader::unsafe_arena_set_allocated_tp(
    ::condenccpp::TypoPolicy* tp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tp_);
  }
  _impl_.tp_ = tp;
  if (tp) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:condenccpp.ConfigHeader.tp)
}
inline ::condenccpp::TypoPolicy* ConfigHeader::release_tp() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::condenccpp::TypoPolicy* temp = _impl_.tp_;
  _impl_.tp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::condenccpp::TypoPolicy* ConfigHeader::unsafe_arena_release_tp() {
  // @@protoc_insertion_point(field_release:condenccpp.ConfigHeader.tp)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::condenccpp::TypoPolicy* temp = _impl_.tp_;
  _impl_.tp_ = nullptr;
  return temp;
}
inline ::condenccpp::TypoPolicy* ConfigHeader::_internal_mutable_tp() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.tp_ == nullptr) {
    auto* p = CreateMaybeMessage<::condenccpp::TypoPolicy>(GetArenaForAllocation());
    _impl_.tp_ = p;
  }
  return _impl_.tp_;
}
inline ::condenccpp::TypoPolicy* ConfigHeader::mutable_tp() {
  ::condenccpp::TypoPolicy* _msg = _internal_mutable_tp();
  // @@protoc_insertion_point(field_mutable:condenccpp.ConfigHeader.tp)
  return _msg;
}
inline void ConfigHeader::set_allocated_tp(::condenccpp::TypoPolicy* tp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tp_;
  }
  if (tp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tp);
    if (message_arena != submessage_arena) {
      tp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tp, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.tp_ = tp;
  // @@protoc_insertion_point(field_set_allocated:condenccpp.ConfigHeader.tp)
}

// required string install_id = 7;
inline bool ConfigHeader::_internal_has_install_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConfigHeader::has_install_id() const {
  return _internal_has_install_id();
}
inline void ConfigHeader::clear_install_id() {
  _impl_.install_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConfigHeader::install_id() const {
  // @@protoc_insertion_point(field_get:condenccpp.ConfigHeader.install_id)
  return _internal_install_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigHeader::set_install_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.install_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:condenccpp.ConfigHeader.install_id)
}
inline std::string* ConfigHeader::mutable_install_id() {
  std::string* _s = _internal_mutable_install_id();
  // @@protoc_insertion_point(field_mutable:condenccpp.ConfigHeader.install_id)
  return _s;
}
inline const std::string& ConfigHeader::_internal_install_id() const {
  return _impl_.install_id_.Get();
}
inline void ConfigHeader::_internal_set_install_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.install_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfigHeader::_internal_mutable_install_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.install_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfigHeader::release_install_id() {
  // @@protoc_insertion_point(field_release:condenccpp.ConfigHeader.install_id)
  if (!_internal_has_install_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.install_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.install_id_.IsDefault()) {
    _impl_.install_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigHeader::set_allocated_install_id(std::string* install_id) {
  if (install_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.install_id_.SetAllocated(install_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.install_id_.IsDefault()) {
    _impl_.install_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:condenccpp.ConfigHeader.install_id)
}

// required bytes public_key = 8;
inline bool ConfigHeader::_internal_has_public_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConfigHeader::has_public_key() const {
  return _internal_has_public_key();
}
inline void ConfigHeader::clear_public_key() {
  _impl_.public_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ConfigHeader::public_key() const {
  // @@protoc_insertion_point(field_get:condenccpp.ConfigHeader.public_key)
  return _internal_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigHeader::set_public_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.public_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:condenccpp.ConfigHeader.public_key)
}
inline std::string* ConfigHeader::mutable_public_key() {
  std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:condenccpp.ConfigHeader.public_key)
  return _s;
}
inline const std::string& ConfigHeader::_internal_public_key() const {
  return _impl_.public_key_.Get();
}
inline void ConfigHeader::_internal_set_public_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.public_key_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfigHeader::_internal_mutable_public_key() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.public_key_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfigHeader::release_public_key() {
  // @@protoc_insertion_point(field_release:condenccpp.ConfigHeader.public_key)
  if (!_internal_has_public_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.public_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.public_key_.IsDefault()) {
    _impl_.public_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigHeader::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.public_key_.SetAllocated(public_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.public_key_.IsDefault()) {
    _impl_.public_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:condenccpp.ConfigHeader.public_key)
}

// required bytes global_salt = 9;
inline bool ConfigHeader::_internal_has_global_salt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConfigHeader::has_global_salt() const {
  return _internal_has_global_salt();
}
inline void ConfigHeader::clear_global_salt() {
  _impl_.global_salt_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ConfigHeader::global_salt() const {
  // @@protoc_insertion_point(field_get:condenccpp.ConfigHeader.global_salt)
  return _internal_global_salt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigHeader::set_global_salt(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.global_salt_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:condenccpp.ConfigHeader.global_salt)
}
inline std::string* ConfigHeader::mutable_global_salt() {
  std::string* _s = _internal_mutable_global_salt();
  // @@protoc_insertion_point(field_mutable:condenccpp.ConfigHeader.global_salt)
  return _s;
}
inline const std::string& ConfigHeader::_internal_global_salt() const {
  return _impl_.global_salt_.Get();
}
inline void ConfigHeader::_internal_set_global_salt(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.global_salt_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfigHeader::_internal_mutable_global_salt() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.global_salt_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfigHeader::release_global_salt() {
  // @@protoc_insertion_point(field_release:condenccpp.ConfigHeader.global_salt)
  if (!_internal_has_global_salt()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.global_salt_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.global_salt_.IsDefault()) {
    _impl_.global_salt_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigHeader::set_allocated_global_salt(std::string* global_salt) {
  if (global_salt != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.global_salt_.SetAllocated(global_salt, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.global_salt_.IsDefault()) {
    _impl_.global_salt_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:condenccpp.ConfigHeader.global_salt)
}

// -------------------------------------------------------------------

// EncHeaderData

// required bytes pw = 1;
inline bool EncHeaderData::_internal_has_pw() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EncHeaderData::has_pw() const {
  return _internal_has_pw();
}
inline void EncHeaderData::clear_pw() {
  _impl_.pw_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& EncHeaderData::pw() const {
  // @@protoc_insertion_point(field_get:condenccpp.EncHeaderData.pw)
  return _internal_pw();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EncHeaderData::set_pw(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.pw_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:condenccpp.EncHeaderData.pw)
}
inline std::string* EncHeaderData::mutable_pw() {
  std::string* _s = _internal_mutable_pw();
  // @@protoc_insertion_point(field_mutable:condenccpp.EncHeaderData.pw)
  return _s;
}
inline const std::string& EncHeaderData::_internal_pw() const {
  return _impl_.pw_.Get();
}
inline void EncHeaderData::_internal_set_pw(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.pw_.Set(value, GetArenaForAllocation());
}
inline std::string* EncHeaderData::_internal_mutable_pw() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.pw_.Mutable(GetArenaForAllocation());
}
inline std::string* EncHeaderData::release_pw() {
  // @@protoc_insertion_point(field_release:condenccpp.EncHeaderData.pw)
  if (!_internal_has_pw()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.pw_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pw_.IsDefault()) {
    _impl_.pw_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void EncHeaderData::set_allocated_pw(std::string* pw) {
  if (pw != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.pw_.SetAllocated(pw, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pw_.IsDefault()) {
    _impl_.pw_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:condenccpp.EncHeaderData.pw)
}

// repeated int32 freq = 2;
inline int EncHeaderData::_internal_freq_size() const {
  return _impl_.freq_.size();
}
inline int EncHeaderData::freq_size() const {
  return _internal_freq_size();
}
inline void EncHeaderData::clear_freq() {
  _impl_.freq_.Clear();
}
inline int32_t EncHeaderData::_internal_freq(int index) const {
  return _impl_.freq_.Get(index);
}
inline int32_t EncHeaderData::freq(int index) const {
  // @@protoc_insertion_point(field_get:condenccpp.EncHeaderData.freq)
  return _internal_freq(index);
}
inline void EncHeaderData::set_freq(int index, int32_t value) {
  _impl_.freq_.Set(index, value);
  // @@protoc_insertion_point(field_set:condenccpp.EncHeaderData.freq)
}
inline void EncHeaderData::_internal_add_freq(int32_t value) {
  _impl_.freq_.Add(value);
}
inline void EncHeaderData::add_freq(int32_t value) {
  _internal_add_freq(value);
  // @@protoc_insertion_point(field_add:condenccpp.EncHeaderData.freq)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
EncHeaderData::_internal_freq() const {
  return _impl_.freq_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
EncHeaderData::freq() const {
  // @@protoc_insertion_point(field_list:condenccpp.EncHeaderData.freq)
  return _internal_freq();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
EncHeaderData::_internal_mutable_freq() {
  return &_impl_.freq_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
EncHeaderData::mutable_freq() {
  // @@protoc_insertion_point(field_mutable_list:condenccpp.EncHeaderData.freq)
  return _internal_mutable_freq();
}

// repeated int64 last_used = 3;
inline int EncHeaderData::_internal_last_used_size() const {
  return _impl_.last_used_.size();
}
inline int EncHeaderData::last_used_size() const {
  return _internal_last_used_size();
}
inline void EncHeaderData::clear_last_used() {
  _impl_.last_used_.Clear();
}
inline int64_t EncHeaderData::_internal_last_used(int index) const {
  return _impl_.last_used_.Get(index);
}
inline int64_t EncHeaderData::last_used(int index) const {
  // @@protoc_insertion_point(field_get:condenccpp.EncHeaderData.last_used)
  return _internal_last_used(index);
}
inline void EncHeaderData::set_last_used(int index, int64_t value) {
  _impl_.last_used_.Set(index, value);
  // @@protoc_insertion_point(field_set:condenccpp.EncHeaderData.last_used)
}
inline void EncHeaderData::_internal_add_last_used(int64_t value) {
  _impl_.last_used_.Add(value);
}
inline void EncHeaderData::add_last_used(int64_t value) {
  _internal_add_last_used(value);
  // @@protoc_insertion_point(field_add:condenccpp.EncHeaderData.last_used)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
EncHeaderData::_internal_last_used() const {
  return _impl_.last_used_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
EncHeaderData::last_used() const {
  // @@protoc_insertion_point(field_list:condenccpp.EncHeaderData.last_used)
  return _internal_last_used();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
EncHeaderData::_internal_mutable_last_used() {
  return &_impl_.last_used_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
EncHeaderData::mutable_last_used() {
  // @@protoc_insertion_point(field_mutable_list:condenccpp.EncHeaderData.last_used)
  return _internal_mutable_last_used();
}

// required float pw_ent = 4;
inline bool EncHeaderData::_internal_has_pw_ent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EncHeaderData::has_pw_ent() const {
  return _internal_has_pw_ent();
}
inline void EncHeaderData::clear_pw_ent() {
  _impl_.pw_ent_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float EncHeaderData::_internal_pw_ent() const {
  return _impl_.pw_ent_;
}
inline float EncHeaderData::pw_ent() const {
  // @@protoc_insertion_point(field_get:condenccpp.EncHeaderData.pw_ent)
  return _internal_pw_ent();
}
inline void EncHeaderData::_internal_set_pw_ent(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pw_ent_ = value;
}
inline void EncHeaderData::set_pw_ent(float value) {
  _internal_set_pw_ent(value);
  // @@protoc_insertion_point(field_set:condenccpp.EncHeaderData.pw_ent)
}

// -------------------------------------------------------------------

// Header

// optional int32 indexj = 1 [default = 0];
inline bool Header::_internal_has_indexj() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Header::has_indexj() const {
  return _internal_has_indexj();
}
inline void Header::clear_indexj() {
  _impl_.indexj_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t Header::_internal_indexj() const {
  return _impl_.indexj_;
}
inline int32_t Header::indexj() const {
  // @@protoc_insertion_point(field_get:condenccpp.Header.indexj)
  return _internal_indexj();
}
inline void Header::_internal_set_indexj(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.indexj_ = value;
}
inline void Header::set_indexj(int32_t value) {
  _internal_set_indexj(value);
  // @@protoc_insertion_point(field_set:condenccpp.Header.indexj)
}

// optional int32 last_log_sent_time = 2 [default = 0];
inline bool Header::_internal_has_last_log_sent_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Header::has_last_log_sent_time() const {
  return _internal_has_last_log_sent_time();
}
inline void Header::clear_last_log_sent_time() {
  _impl_.last_log_sent_time_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t Header::_internal_last_log_sent_time() const {
  return _impl_.last_log_sent_time_;
}
inline int32_t Header::last_log_sent_time() const {
  // @@protoc_insertion_point(field_get:condenccpp.Header.last_log_sent_time)
  return _internal_last_log_sent_time();
}
inline void Header::_internal_set_last_log_sent_time(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.last_log_sent_time_ = value;
}
inline void Header::set_last_log_sent_time(int32_t value) {
  _internal_set_last_log_sent_time(value);
  // @@protoc_insertion_point(field_set:condenccpp.Header.last_log_sent_time)
}

// optional int32 login_count = 3 [default = 0];
inline bool Header::_internal_has_login_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Header::has_login_count() const {
  return _internal_has_login_count();
}
inline void Header::clear_login_count() {
  _impl_.login_count_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t Header::_internal_login_count() const {
  return _impl_.login_count_;
}
inline int32_t Header::login_count() const {
  // @@protoc_insertion_point(field_get:condenccpp.Header.login_count)
  return _internal_login_count();
}
inline void Header::_internal_set_login_count(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.login_count_ = value;
}
inline void Header::set_login_count(int32_t value) {
  _internal_set_login_count(value);
  // @@protoc_insertion_point(field_set:condenccpp.Header.login_count)
}

// optional .condenccpp.SystemStatus sys_state = 4 [default = UNINITIALIZED];
inline bool Header::_internal_has_sys_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Header::has_sys_state() const {
  return _internal_has_sys_state();
}
inline void Header::clear_sys_state() {
  _impl_.sys_state_ = 3;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::condenccpp::SystemStatus Header::_internal_sys_state() const {
  return static_cast< ::condenccpp::SystemStatus >(_impl_.sys_state_);
}
inline ::condenccpp::SystemStatus Header::sys_state() const {
  // @@protoc_insertion_point(field_get:condenccpp.Header.sys_state)
  return _internal_sys_state();
}
inline void Header::_internal_set_sys_state(::condenccpp::SystemStatus value) {
  assert(::condenccpp::SystemStatus_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.sys_state_ = value;
}
inline void Header::set_sys_state(::condenccpp::SystemStatus value) {
  _internal_set_sys_state(value);
  // @@protoc_insertion_point(field_set:condenccpp.Header.sys_state)
}

// required bytes enc_header = 5;
inline bool Header::_internal_has_enc_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Header::has_enc_header() const {
  return _internal_has_enc_header();
}
inline void Header::clear_enc_header() {
  _impl_.enc_header_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Header::enc_header() const {
  // @@protoc_insertion_point(field_get:condenccpp.Header.enc_header)
  return _internal_enc_header();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Header::set_enc_header(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.enc_header_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:condenccpp.Header.enc_header)
}
inline std::string* Header::mutable_enc_header() {
  std::string* _s = _internal_mutable_enc_header();
  // @@protoc_insertion_point(field_mutable:condenccpp.Header.enc_header)
  return _s;
}
inline const std::string& Header::_internal_enc_header() const {
  return _impl_.enc_header_.Get();
}
inline void Header::_internal_set_enc_header(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.enc_header_.Set(value, GetArenaForAllocation());
}
inline std::string* Header::_internal_mutable_enc_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.enc_header_.Mutable(GetArenaForAllocation());
}
inline std::string* Header::release_enc_header() {
  // @@protoc_insertion_point(field_release:condenccpp.Header.enc_header)
  if (!_internal_has_enc_header()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.enc_header_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.enc_header_.IsDefault()) {
    _impl_.enc_header_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Header::set_allocated_enc_header(std::string* enc_header) {
  if (enc_header != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.enc_header_.SetAllocated(enc_header, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.enc_header_.IsDefault()) {
    _impl_.enc_header_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:condenccpp.Header.enc_header)
}

// -------------------------------------------------------------------

// Logs

// repeated .condenccpp.Log L = 1;
inline int Logs::_internal_l_size() const {
  return _impl_.l_.size();
}
inline int Logs::l_size() const {
  return _internal_l_size();
}
inline void Logs::clear_l() {
  _impl_.l_.Clear();
}
inline ::condenccpp::Log* Logs::mutable_l(int index) {
  // @@protoc_insertion_point(field_mutable:condenccpp.Logs.L)
  return _impl_.l_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::condenccpp::Log >*
Logs::mutable_l() {
  // @@protoc_insertion_point(field_mutable_list:condenccpp.Logs.L)
  return &_impl_.l_;
}
inline const ::condenccpp::Log& Logs::_internal_l(int index) const {
  return _impl_.l_.Get(index);
}
inline const ::condenccpp::Log& Logs::l(int index) const {
  // @@protoc_insertion_point(field_get:condenccpp.Logs.L)
  return _internal_l(index);
}
inline ::condenccpp::Log* Logs::_internal_add_l() {
  return _impl_.l_.Add();
}
inline ::condenccpp::Log* Logs::add_l() {
  ::condenccpp::Log* _add = _internal_add_l();
  // @@protoc_insertion_point(field_add:condenccpp.Logs.L)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::condenccpp::Log >&
Logs::l() const {
  // @@protoc_insertion_point(field_list:condenccpp.Logs.L)
  return _impl_.l_;
}

// optional int32 typos = 2 [default = 0];
inline bool Logs::_internal_has_typos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Logs::has_typos() const {
  return _internal_has_typos();
}
inline void Logs::clear_typos() {
  _impl_.typos_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t Logs::_internal_typos() const {
  return _impl_.typos_;
}
inline int32_t Logs::typos() const {
  // @@protoc_insertion_point(field_get:condenccpp.Logs.typos)
  return _internal_typos();
}
inline void Logs::_internal_set_typos(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.typos_ = value;
}
inline void Logs::set_typos(int32_t value) {
  _internal_set_typos(value);
  // @@protoc_insertion_point(field_set:condenccpp.Logs.typos)
}

// optional int32 typos_saved = 3 [default = 0];
inline bool Logs::_internal_has_typos_saved() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Logs::has_typos_saved() const {
  return _internal_has_typos_saved();
}
inline void Logs::clear_typos_saved() {
  _impl_.typos_saved_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t Logs::_internal_typos_saved() const {
  return _impl_.typos_saved_;
}
inline int32_t Logs::typos_saved() const {
  // @@protoc_insertion_point(field_get:condenccpp.Logs.typos_saved)
  return _internal_typos_saved();
}
inline void Logs::_internal_set_typos_saved(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.typos_saved_ = value;
}
inline void Logs::set_typos_saved(int32_t value) {
  _internal_set_typos_saved(value);
  // @@protoc_insertion_point(field_set:condenccpp.Logs.typos_saved)
}

// -------------------------------------------------------------------

// typoDB

// optional string version = 9 [default = "1"];
inline bool typoDB::_internal_has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool typoDB::has_version() const {
  return _internal_has_version();
}
inline void typoDB::clear_version() {
  _impl_.version_.ClearToDefault(::condenccpp::typoDB::Impl_::_i_give_permission_to_break_this_code_default_version_, GetArenaForAllocation());
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& typoDB::version() const {
  // @@protoc_insertion_point(field_get:condenccpp.typoDB.version)
  if (_impl_.version_.IsDefault()) return Impl_::_i_give_permission_to_break_this_code_default_version_.get();
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void typoDB::set_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:condenccpp.typoDB.version)
}
inline std::string* typoDB::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:condenccpp.typoDB.version)
  return _s;
}
inline const std::string& typoDB::_internal_version() const {
  return _impl_.version_.Get();
}
inline void typoDB::_internal_set_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* typoDB::_internal_mutable_version() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.version_.Mutable(::condenccpp::typoDB::Impl_::_i_give_permission_to_break_this_code_default_version_, GetArenaForAllocation());
}
inline std::string* typoDB::release_version() {
  // @@protoc_insertion_point(field_release:condenccpp.typoDB.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.version_.Release();
  return p;
}
inline void typoDB::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:condenccpp.typoDB.version)
}

// required .condenccpp.ConfigHeader CH = 1;
inline bool typoDB::_internal_has_ch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ch_ != nullptr);
  return value;
}
inline bool typoDB::has_ch() const {
  return _internal_has_ch();
}
inline void typoDB::clear_ch() {
  if (_impl_.ch_ != nullptr) _impl_.ch_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::condenccpp::ConfigHeader& typoDB::_internal_ch() const {
  const ::condenccpp::ConfigHeader* p = _impl_.ch_;
  return p != nullptr ? *p : reinterpret_cast<const ::condenccpp::ConfigHeader&>(
      ::condenccpp::_ConfigHeader_default_instance_);
}
inline const ::condenccpp::ConfigHeader& typoDB::ch() const {
  // @@protoc_insertion_point(field_get:condenccpp.typoDB.CH)
  return _internal_ch();
}
inline void typoDB::unsafe_arena_set_allocated_ch(
    ::condenccpp::ConfigHeader* ch) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ch_);
  }
  _impl_.ch_ = ch;
  if (ch) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:condenccpp.typoDB.CH)
}
inline ::condenccpp::ConfigHeader* typoDB::release_ch() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::condenccpp::ConfigHeader* temp = _impl_.ch_;
  _impl_.ch_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::condenccpp::ConfigHeader* typoDB::unsafe_arena_release_ch() {
  // @@protoc_insertion_point(field_release:condenccpp.typoDB.CH)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::condenccpp::ConfigHeader* temp = _impl_.ch_;
  _impl_.ch_ = nullptr;
  return temp;
}
inline ::condenccpp::ConfigHeader* typoDB::_internal_mutable_ch() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.ch_ == nullptr) {
    auto* p = CreateMaybeMessage<::condenccpp::ConfigHeader>(GetArenaForAllocation());
    _impl_.ch_ = p;
  }
  return _impl_.ch_;
}
inline ::condenccpp::ConfigHeader* typoDB::mutable_ch() {
  ::condenccpp::ConfigHeader* _msg = _internal_mutable_ch();
  // @@protoc_insertion_point(field_mutable:condenccpp.typoDB.CH)
  return _msg;
}
inline void typoDB::set_allocated_ch(::condenccpp::ConfigHeader* ch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ch_;
  }
  if (ch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ch);
    if (message_arena != submessage_arena) {
      ch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ch, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.ch_ = ch;
  // @@protoc_insertion_point(field_set_allocated:condenccpp.typoDB.CH)
}

// required .condenccpp.Header H = 2;
inline bool typoDB::_internal_has_h() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.h_ != nullptr);
  return value;
}
inline bool typoDB::has_h() const {
  return _internal_has_h();
}
inline void typoDB::clear_h() {
  if (_impl_.h_ != nullptr) _impl_.h_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::condenccpp::Header& typoDB::_internal_h() const {
  const ::condenccpp::Header* p = _impl_.h_;
  return p != nullptr ? *p : reinterpret_cast<const ::condenccpp::Header&>(
      ::condenccpp::_Header_default_instance_);
}
inline const ::condenccpp::Header& typoDB::h() const {
  // @@protoc_insertion_point(field_get:condenccpp.typoDB.H)
  return _internal_h();
}
inline void typoDB::unsafe_arena_set_allocated_h(
    ::condenccpp::Header* h) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.h_);
  }
  _impl_.h_ = h;
  if (h) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:condenccpp.typoDB.H)
}
inline ::condenccpp::Header* typoDB::release_h() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::condenccpp::Header* temp = _impl_.h_;
  _impl_.h_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::condenccpp::Header* typoDB::unsafe_arena_release_h() {
  // @@protoc_insertion_point(field_release:condenccpp.typoDB.H)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::condenccpp::Header* temp = _impl_.h_;
  _impl_.h_ = nullptr;
  return temp;
}
inline ::condenccpp::Header* typoDB::_internal_mutable_h() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.h_ == nullptr) {
    auto* p = CreateMaybeMessage<::condenccpp::Header>(GetArenaForAllocation());
    _impl_.h_ = p;
  }
  return _impl_.h_;
}
inline ::condenccpp::Header* typoDB::mutable_h() {
  ::condenccpp::Header* _msg = _internal_mutable_h();
  // @@protoc_insertion_point(field_mutable:condenccpp.typoDB.H)
  return _msg;
}
inline void typoDB::set_allocated_h(::condenccpp::Header* h) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.h_;
  }
  if (h) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(h);
    if (message_arena != submessage_arena) {
      h = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, h, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.h_ = h;
  // @@protoc_insertion_point(field_set_allocated:condenccpp.typoDB.H)
}

// repeated bytes W = 3;
inline int typoDB::_internal_w_size() const {
  return _impl_.w_.size();
}
inline int typoDB::w_size() const {
  return _internal_w_size();
}
inline void typoDB::clear_w() {
  _impl_.w_.Clear();
}
inline std::string* typoDB::add_w() {
  std::string* _s = _internal_add_w();
  // @@protoc_insertion_point(field_add_mutable:condenccpp.typoDB.W)
  return _s;
}
inline const std::string& typoDB::_internal_w(int index) const {
  return _impl_.w_.Get(index);
}
inline const std::string& typoDB::w(int index) const {
  // @@protoc_insertion_point(field_get:condenccpp.typoDB.W)
  return _internal_w(index);
}
inline std::string* typoDB::mutable_w(int index) {
  // @@protoc_insertion_point(field_mutable:condenccpp.typoDB.W)
  return _impl_.w_.Mutable(index);
}
inline void typoDB::set_w(int index, const std::string& value) {
  _impl_.w_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:condenccpp.typoDB.W)
}
inline void typoDB::set_w(int index, std::string&& value) {
  _impl_.w_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:condenccpp.typoDB.W)
}
inline void typoDB::set_w(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.w_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:condenccpp.typoDB.W)
}
inline void typoDB::set_w(int index, const void* value, size_t size) {
  _impl_.w_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:condenccpp.typoDB.W)
}
inline std::string* typoDB::_internal_add_w() {
  return _impl_.w_.Add();
}
inline void typoDB::add_w(const std::string& value) {
  _impl_.w_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:condenccpp.typoDB.W)
}
inline void typoDB::add_w(std::string&& value) {
  _impl_.w_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:condenccpp.typoDB.W)
}
inline void typoDB::add_w(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.w_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:condenccpp.typoDB.W)
}
inline void typoDB::add_w(const void* value, size_t size) {
  _impl_.w_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:condenccpp.typoDB.W)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
typoDB::w() const {
  // @@protoc_insertion_point(field_list:condenccpp.typoDB.W)
  return _impl_.w_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
typoDB::mutable_w() {
  // @@protoc_insertion_point(field_mutable_list:condenccpp.typoDB.W)
  return &_impl_.w_;
}

// repeated bytes T = 4;
inline int typoDB::_internal_t_size() const {
  return _impl_.t_.size();
}
inline int typoDB::t_size() const {
  return _internal_t_size();
}
inline void typoDB::clear_t() {
  _impl_.t_.Clear();
}
inline std::string* typoDB::add_t() {
  std::string* _s = _internal_add_t();
  // @@protoc_insertion_point(field_add_mutable:condenccpp.typoDB.T)
  return _s;
}
inline const std::string& typoDB::_internal_t(int index) const {
  return _impl_.t_.Get(index);
}
inline const std::string& typoDB::t(int index) const {
  // @@protoc_insertion_point(field_get:condenccpp.typoDB.T)
  return _internal_t(index);
}
inline std::string* typoDB::mutable_t(int index) {
  // @@protoc_insertion_point(field_mutable:condenccpp.typoDB.T)
  return _impl_.t_.Mutable(index);
}
inline void typoDB::set_t(int index, const std::string& value) {
  _impl_.t_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:condenccpp.typoDB.T)
}
inline void typoDB::set_t(int index, std::string&& value) {
  _impl_.t_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:condenccpp.typoDB.T)
}
inline void typoDB::set_t(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.t_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:condenccpp.typoDB.T)
}
inline void typoDB::set_t(int index, const void* value, size_t size) {
  _impl_.t_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:condenccpp.typoDB.T)
}
inline std::string* typoDB::_internal_add_t() {
  return _impl_.t_.Add();
}
inline void typoDB::add_t(const std::string& value) {
  _impl_.t_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:condenccpp.typoDB.T)
}
inline void typoDB::add_t(std::string&& value) {
  _impl_.t_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:condenccpp.typoDB.T)
}
inline void typoDB::add_t(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.t_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:condenccpp.typoDB.T)
}
inline void typoDB::add_t(const void* value, size_t size) {
  _impl_.t_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:condenccpp.typoDB.T)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
typoDB::t() const {
  // @@protoc_insertion_point(field_list:condenccpp.typoDB.T)
  return _impl_.t_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
typoDB::mutable_t() {
  // @@protoc_insertion_point(field_mutable_list:condenccpp.typoDB.T)
  return &_impl_.t_;
}

// optional .condenccpp.Logs logs = 5;
inline bool typoDB::_internal_has_logs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.logs_ != nullptr);
  return value;
}
inline bool typoDB::has_logs() const {
  return _internal_has_logs();
}
inline void typoDB::clear_logs() {
  if (_impl_.logs_ != nullptr) _impl_.logs_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::condenccpp::Logs& typoDB::_internal_logs() const {
  const ::condenccpp::Logs* p = _impl_.logs_;
  return p != nullptr ? *p : reinterpret_cast<const ::condenccpp::Logs&>(
      ::condenccpp::_Logs_default_instance_);
}
inline const ::condenccpp::Logs& typoDB::logs() const {
  // @@protoc_insertion_point(field_get:condenccpp.typoDB.logs)
  return _internal_logs();
}
inline void typoDB::unsafe_arena_set_allocated_logs(
    ::condenccpp::Logs* logs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.logs_);
  }
  _impl_.logs_ = logs;
  if (logs) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:condenccpp.typoDB.logs)
}
inline ::condenccpp::Logs* typoDB::release_logs() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::condenccpp::Logs* temp = _impl_.logs_;
  _impl_.logs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::condenccpp::Logs* typoDB::unsafe_arena_release_logs() {
  // @@protoc_insertion_point(field_release:condenccpp.typoDB.logs)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::condenccpp::Logs* temp = _impl_.logs_;
  _impl_.logs_ = nullptr;
  return temp;
}
inline ::condenccpp::Logs* typoDB::_internal_mutable_logs() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.logs_ == nullptr) {
    auto* p = CreateMaybeMessage<::condenccpp::Logs>(GetArenaForAllocation());
    _impl_.logs_ = p;
  }
  return _impl_.logs_;
}
inline ::condenccpp::Logs* typoDB::mutable_logs() {
  ::condenccpp::Logs* _msg = _internal_mutable_logs();
  // @@protoc_insertion_point(field_mutable:condenccpp.typoDB.logs)
  return _msg;
}
inline void typoDB::set_allocated_logs(::condenccpp::Logs* logs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.logs_;
  }
  if (logs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(logs);
    if (message_arena != submessage_arena) {
      logs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logs, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.logs_ = logs;
  // @@protoc_insertion_point(field_set_allocated:condenccpp.typoDB.logs)
}

// required bytes rlpwdctxorenc = 6;
inline bool typoDB::_internal_has_rlpwdctxorenc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool typoDB::has_rlpwdctxorenc() const {
  return _internal_has_rlpwdctxorenc();
}
inline void typoDB::clear_rlpwdctxorenc() {
  _impl_.rlpwdctxorenc_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& typoDB::rlpwdctxorenc() const {
  // @@protoc_insertion_point(field_get:condenccpp.typoDB.rlpwdctxorenc)
  return _internal_rlpwdctxorenc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void typoDB::set_rlpwdctxorenc(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.rlpwdctxorenc_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:condenccpp.typoDB.rlpwdctxorenc)
}
inline std::string* typoDB::mutable_rlpwdctxorenc() {
  std::string* _s = _internal_mutable_rlpwdctxorenc();
  // @@protoc_insertion_point(field_mutable:condenccpp.typoDB.rlpwdctxorenc)
  return _s;
}
inline const std::string& typoDB::_internal_rlpwdctxorenc() const {
  return _impl_.rlpwdctxorenc_.Get();
}
inline void typoDB::_internal_set_rlpwdctxorenc(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.rlpwdctxorenc_.Set(value, GetArenaForAllocation());
}
inline std::string* typoDB::_internal_mutable_rlpwdctxorenc() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.rlpwdctxorenc_.Mutable(GetArenaForAllocation());
}
inline std::string* typoDB::release_rlpwdctxorenc() {
  // @@protoc_insertion_point(field_release:condenccpp.typoDB.rlpwdctxorenc)
  if (!_internal_has_rlpwdctxorenc()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.rlpwdctxorenc_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rlpwdctxorenc_.IsDefault()) {
    _impl_.rlpwdctxorenc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void typoDB::set_allocated_rlpwdctxorenc(std::string* rlpwdctxorenc) {
  if (rlpwdctxorenc != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.rlpwdctxorenc_.SetAllocated(rlpwdctxorenc, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rlpwdctxorenc_.IsDefault()) {
    _impl_.rlpwdctxorenc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:condenccpp.typoDB.rlpwdctxorenc)
}

// -------------------------------------------------------------------

// WaitlistEntry

// required bytes pw = 1;
inline bool WaitlistEntry::_internal_has_pw() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool WaitlistEntry::has_pw() const {
  return _internal_has_pw();
}
inline void WaitlistEntry::clear_pw() {
  _impl_.pw_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& WaitlistEntry::pw() const {
  // @@protoc_insertion_point(field_get:condenccpp.WaitlistEntry.pw)
  return _internal_pw();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WaitlistEntry::set_pw(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.pw_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:condenccpp.WaitlistEntry.pw)
}
inline std::string* WaitlistEntry::mutable_pw() {
  std::string* _s = _internal_mutable_pw();
  // @@protoc_insertion_point(field_mutable:condenccpp.WaitlistEntry.pw)
  return _s;
}
inline const std::string& WaitlistEntry::_internal_pw() const {
  return _impl_.pw_.Get();
}
inline void WaitlistEntry::_internal_set_pw(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.pw_.Set(value, GetArenaForAllocation());
}
inline std::string* WaitlistEntry::_internal_mutable_pw() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.pw_.Mutable(GetArenaForAllocation());
}
inline std::string* WaitlistEntry::release_pw() {
  // @@protoc_insertion_point(field_release:condenccpp.WaitlistEntry.pw)
  if (!_internal_has_pw()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.pw_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pw_.IsDefault()) {
    _impl_.pw_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void WaitlistEntry::set_allocated_pw(std::string* pw) {
  if (pw != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.pw_.SetAllocated(pw, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pw_.IsDefault()) {
    _impl_.pw_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:condenccpp.WaitlistEntry.pw)
}

// required int64 ts = 2 [default = -1];
inline bool WaitlistEntry::_internal_has_ts() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool WaitlistEntry::has_ts() const {
  return _internal_has_ts();
}
inline void WaitlistEntry::clear_ts() {
  _impl_.ts_ = int64_t{-1};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t WaitlistEntry::_internal_ts() const {
  return _impl_.ts_;
}
inline int64_t WaitlistEntry::ts() const {
  // @@protoc_insertion_point(field_get:condenccpp.WaitlistEntry.ts)
  return _internal_ts();
}
inline void WaitlistEntry::_internal_set_ts(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ts_ = value;
}
inline void WaitlistEntry::set_ts(int64_t value) {
  _internal_set_ts(value);
  // @@protoc_insertion_point(field_set:condenccpp.WaitlistEntry.ts)
}

// -------------------------------------------------------------------

// PwdCtxORPredicate

// optional string rlpwdctx = 1;
inline bool PwdCtxORPredicate::_internal_has_rlpwdctx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PwdCtxORPredicate::has_rlpwdctx() const {
  return _internal_has_rlpwdctx();
}
inline void PwdCtxORPredicate::clear_rlpwdctx() {
  _impl_.rlpwdctx_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PwdCtxORPredicate::rlpwdctx() const {
  // @@protoc_insertion_point(field_get:condenccpp.PwdCtxORPredicate.rlpwdctx)
  return _internal_rlpwdctx();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PwdCtxORPredicate::set_rlpwdctx(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.rlpwdctx_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:condenccpp.PwdCtxORPredicate.rlpwdctx)
}
inline std::string* PwdCtxORPredicate::mutable_rlpwdctx() {
  std::string* _s = _internal_mutable_rlpwdctx();
  // @@protoc_insertion_point(field_mutable:condenccpp.PwdCtxORPredicate.rlpwdctx)
  return _s;
}
inline const std::string& PwdCtxORPredicate::_internal_rlpwdctx() const {
  return _impl_.rlpwdctx_.Get();
}
inline void PwdCtxORPredicate::_internal_set_rlpwdctx(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.rlpwdctx_.Set(value, GetArenaForAllocation());
}
inline std::string* PwdCtxORPredicate::_internal_mutable_rlpwdctx() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.rlpwdctx_.Mutable(GetArenaForAllocation());
}
inline std::string* PwdCtxORPredicate::release_rlpwdctx() {
  // @@protoc_insertion_point(field_release:condenccpp.PwdCtxORPredicate.rlpwdctx)
  if (!_internal_has_rlpwdctx()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.rlpwdctx_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rlpwdctx_.IsDefault()) {
    _impl_.rlpwdctx_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PwdCtxORPredicate::set_allocated_rlpwdctx(std::string* rlpwdctx) {
  if (rlpwdctx != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.rlpwdctx_.SetAllocated(rlpwdctx, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rlpwdctx_.IsDefault()) {
    _impl_.rlpwdctx_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:condenccpp.PwdCtxORPredicate.rlpwdctx)
}

// optional string rlpwdctxorenc = 2;
inline bool PwdCtxORPredicate::_internal_has_rlpwdctxorenc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PwdCtxORPredicate::has_rlpwdctxorenc() const {
  return _internal_has_rlpwdctxorenc();
}
inline void PwdCtxORPredicate::clear_rlpwdctxorenc() {
  _impl_.rlpwdctxorenc_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PwdCtxORPredicate::rlpwdctxorenc() const {
  // @@protoc_insertion_point(field_get:condenccpp.PwdCtxORPredicate.rlpwdctxorenc)
  return _internal_rlpwdctxorenc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PwdCtxORPredicate::set_rlpwdctxorenc(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.rlpwdctxorenc_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:condenccpp.PwdCtxORPredicate.rlpwdctxorenc)
}
inline std::string* PwdCtxORPredicate::mutable_rlpwdctxorenc() {
  std::string* _s = _internal_mutable_rlpwdctxorenc();
  // @@protoc_insertion_point(field_mutable:condenccpp.PwdCtxORPredicate.rlpwdctxorenc)
  return _s;
}
inline const std::string& PwdCtxORPredicate::_internal_rlpwdctxorenc() const {
  return _impl_.rlpwdctxorenc_.Get();
}
inline void PwdCtxORPredicate::_internal_set_rlpwdctxorenc(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.rlpwdctxorenc_.Set(value, GetArenaForAllocation());
}
inline std::string* PwdCtxORPredicate::_internal_mutable_rlpwdctxorenc() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.rlpwdctxorenc_.Mutable(GetArenaForAllocation());
}
inline std::string* PwdCtxORPredicate::release_rlpwdctxorenc() {
  // @@protoc_insertion_point(field_release:condenccpp.PwdCtxORPredicate.rlpwdctxorenc)
  if (!_internal_has_rlpwdctxorenc()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.rlpwdctxorenc_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rlpwdctxorenc_.IsDefault()) {
    _impl_.rlpwdctxorenc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PwdCtxORPredicate::set_allocated_rlpwdctxorenc(std::string* rlpwdctxorenc) {
  if (rlpwdctxorenc != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.rlpwdctxorenc_.SetAllocated(rlpwdctxorenc, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rlpwdctxorenc_.IsDefault()) {
    _impl_.rlpwdctxorenc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:condenccpp.PwdCtxORPredicate.rlpwdctxorenc)
}

// optional string rlpwdctxorcenc = 3;
inline bool PwdCtxORPredicate::_internal_has_rlpwdctxorcenc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PwdCtxORPredicate::has_rlpwdctxorcenc() const {
  return _internal_has_rlpwdctxorcenc();
}
inline void PwdCtxORPredicate::clear_rlpwdctxorcenc() {
  _impl_.rlpwdctxorcenc_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PwdCtxORPredicate::rlpwdctxorcenc() const {
  // @@protoc_insertion_point(field_get:condenccpp.PwdCtxORPredicate.rlpwdctxorcenc)
  return _internal_rlpwdctxorcenc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PwdCtxORPredicate::set_rlpwdctxorcenc(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.rlpwdctxorcenc_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:condenccpp.PwdCtxORPredicate.rlpwdctxorcenc)
}
inline std::string* PwdCtxORPredicate::mutable_rlpwdctxorcenc() {
  std::string* _s = _internal_mutable_rlpwdctxorcenc();
  // @@protoc_insertion_point(field_mutable:condenccpp.PwdCtxORPredicate.rlpwdctxorcenc)
  return _s;
}
inline const std::string& PwdCtxORPredicate::_internal_rlpwdctxorcenc() const {
  return _impl_.rlpwdctxorcenc_.Get();
}
inline void PwdCtxORPredicate::_internal_set_rlpwdctxorcenc(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.rlpwdctxorcenc_.Set(value, GetArenaForAllocation());
}
inline std::string* PwdCtxORPredicate::_internal_mutable_rlpwdctxorcenc() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.rlpwdctxorcenc_.Mutable(GetArenaForAllocation());
}
inline std::string* PwdCtxORPredicate::release_rlpwdctxorcenc() {
  // @@protoc_insertion_point(field_release:condenccpp.PwdCtxORPredicate.rlpwdctxorcenc)
  if (!_internal_has_rlpwdctxorcenc()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.rlpwdctxorcenc_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rlpwdctxorcenc_.IsDefault()) {
    _impl_.rlpwdctxorcenc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PwdCtxORPredicate::set_allocated_rlpwdctxorcenc(std::string* rlpwdctxorcenc) {
  if (rlpwdctxorcenc != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.rlpwdctxorcenc_.SetAllocated(rlpwdctxorcenc, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rlpwdctxorcenc_.IsDefault()) {
    _impl_.rlpwdctxorcenc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:condenccpp.PwdCtxORPredicate.rlpwdctxorcenc)
}

// -------------------------------------------------------------------

// PaillierPK

// optional bytes Pail_PK = 1;
inline bool PaillierPK::_internal_has_pail_pk() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PaillierPK::has_pail_pk() const {
  return _internal_has_pail_pk();
}
inline void PaillierPK::clear_pail_pk() {
  _impl_.pail_pk_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PaillierPK::pail_pk() const {
  // @@protoc_insertion_point(field_get:condenccpp.PaillierPK.Pail_PK)
  return _internal_pail_pk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PaillierPK::set_pail_pk(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.pail_pk_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:condenccpp.PaillierPK.Pail_PK)
}
inline std::string* PaillierPK::mutable_pail_pk() {
  std::string* _s = _internal_mutable_pail_pk();
  // @@protoc_insertion_point(field_mutable:condenccpp.PaillierPK.Pail_PK)
  return _s;
}
inline const std::string& PaillierPK::_internal_pail_pk() const {
  return _impl_.pail_pk_.Get();
}
inline void PaillierPK::_internal_set_pail_pk(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.pail_pk_.Set(value, GetArenaForAllocation());
}
inline std::string* PaillierPK::_internal_mutable_pail_pk() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.pail_pk_.Mutable(GetArenaForAllocation());
}
inline std::string* PaillierPK::release_pail_pk() {
  // @@protoc_insertion_point(field_release:condenccpp.PaillierPK.Pail_PK)
  if (!_internal_has_pail_pk()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.pail_pk_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pail_pk_.IsDefault()) {
    _impl_.pail_pk_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PaillierPK::set_allocated_pail_pk(std::string* pail_pk) {
  if (pail_pk != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.pail_pk_.SetAllocated(pail_pk, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pail_pk_.IsDefault()) {
    _impl_.pail_pk_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:condenccpp.PaillierPK.Pail_PK)
}

// optional bytes Pail_Sk = 2;
inline bool PaillierPK::_internal_has_pail_sk() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PaillierPK::has_pail_sk() const {
  return _internal_has_pail_sk();
}
inline void PaillierPK::clear_pail_sk() {
  _impl_.pail_sk_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PaillierPK::pail_sk() const {
  // @@protoc_insertion_point(field_get:condenccpp.PaillierPK.Pail_Sk)
  return _internal_pail_sk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PaillierPK::set_pail_sk(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.pail_sk_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:condenccpp.PaillierPK.Pail_Sk)
}
inline std::string* PaillierPK::mutable_pail_sk() {
  std::string* _s = _internal_mutable_pail_sk();
  // @@protoc_insertion_point(field_mutable:condenccpp.PaillierPK.Pail_Sk)
  return _s;
}
inline const std::string& PaillierPK::_internal_pail_sk() const {
  return _impl_.pail_sk_.Get();
}
inline void PaillierPK::_internal_set_pail_sk(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pail_sk_.Set(value, GetArenaForAllocation());
}
inline std::string* PaillierPK::_internal_mutable_pail_sk() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.pail_sk_.Mutable(GetArenaForAllocation());
}
inline std::string* PaillierPK::release_pail_sk() {
  // @@protoc_insertion_point(field_release:condenccpp.PaillierPK.Pail_Sk)
  if (!_internal_has_pail_sk()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.pail_sk_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pail_sk_.IsDefault()) {
    _impl_.pail_sk_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PaillierPK::set_allocated_pail_sk(std::string* pail_sk) {
  if (pail_sk != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.pail_sk_.SetAllocated(pail_sk, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pail_sk_.IsDefault()) {
    _impl_.pail_sk_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:condenccpp.PaillierPK.Pail_Sk)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace condenccpp

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::condenccpp::SystemStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::condenccpp::SystemStatus>() {
  return ::condenccpp::SystemStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_db_2eproto
