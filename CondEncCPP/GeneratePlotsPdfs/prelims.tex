% !TEX root = main.tex

\subsection{Preliminaries}\seclab{preliminaries}
In this section, we review the notations and cryptographic primitive which will be used in the rest of the paper. \newline 

Given a randomized algorithm $\A$ (e.g., key-generation)  we use $y=A(x;r)$ to denote the deterministic output of $A$ when run on input $x$ with fixed random $r \in \{0,1\}^*$ and we use the random variable  $y \leftarrow \A(x)$ to denote the output of $A(x;r)$ when $r$ is selected randomly.  

Let  $ \Sigma $ denote an alphabet (e.g., ASCII or unicode). Given a string $w \in \Sigma^*$ we use $\norm{w}$ to denote the length of $w$ and for $i \leq \norm{w}$ we use $w[i]$ to denote the $i$th character of $w$. We let $\M_n = \Sigma^{\leq n}$ denote the set of all strings $w$ with length $\norm{w} \leq n$. It will be convenient to assume that all passwords have the same length. Of course most user passwords do not have the same length but if the maximum length of a user password is $n-1$ then we can easily define a $1$ to $1$ function $\Pad:\Sigma^{\leq n-1} \rightarrow \Sigma^n$ and consider $\Pwd = \Sigma^n$ to be the set of all possible user passwords after padding. In practice, we could select $n=30$ as essentially all user passwords are shorter than this (e.g., over $99.9\%$ of leaked RockYou passwords were less than 30 characters.). The symbol ``$\|$'' will be used for concatenation. Thus, $ y = x_1 \| x_2 $ is concatenation of $ x_1 $ and $ x_2 $. \newline

Let $ L = \langle l_1, \ldots, l_{|L|}  \rangle $ be list of $ |L| $ elements. We also define the operation $ L' = \apnd(L, l) $ which adds $ l $ to the list and we have $ L' =  \langle l_1, \ldots, l_{|L|}, l \rangle $. We note that $ l_i $ can be an element in $ \Mbb{Z}_{N^2}, \Sigma^n, \M_n$ or $ \Pwd $, etc.  \newline

For the message $m \in \Sigma^{\leq n}$ we use the notation  $m_{-i} \in \Sigma^{\leq n-1} $ to denote the string $ m$ when the $ i $-th char is deleted and if $i > |m|$ then $m_{-i}=m$.

\subsubsection{Partially homomorphic Encryption}
The  Paillier cryptosystem is a partially homomorphic cryptographic scheme which supports ciphertext addition, plaintext to ciphertext multiplication and subtraction.  Specifically, the public key $pk=(N,g)$ (resp. secret key $sk=(\beta, \mu)$) consists of $N=pq$ where $p,q$ are prime numbers and the number $g=N+1 \in \mathbb{Z}_{N^2}^*$ (resp. $\beta =\lcm(p-1,q-1)$ and $\mu=\varphi(N)^{-1} \mod N$). We note that for all $i \in \mathbb{Z}_N$ we have $g^i = \sum_{j=0}^i {i \choose j} N^j = 1+Ni \mod{N^2}$ so that $g$ has multiplicative order $N$ modulo $N^2$. The secret key $sk=(\beta,\mu)$ consists of two parameters $\beta=\lcm(p-1,q-1)$ and $\mu = \varphi(N)^{-1} \mod N$ is defined to be the multiplicative inverse of $\varphi(N) = (p-1)(q-1)$ modulo $N$. \\ 

The algorithm $\Enc_{pk}(m;r)$ takes as input a message $m \in \mathbb{Z}_N$ and a nonce $r \in \mathbb{Z}_N^*$ and outputs $g^{m}r^N \mod{N^2}$. The function $\Enc_{pk}$ acts as a bijective map from $\mathbb{Z}_N \times \mathbb{Z}_N^* \rightarrow \mathbb{Z}_{N^2}^*$. In particular, for {\em every} $c \in \mathbb{Z}_{N^2}^*$ there is a message $m \in \mathbb{Z}_N$ and a nonce $r \in \mathbb{Z}_N^*$ such that $c=g^m r^N \mod{N^2}$ \cite{EC:Paillier99}. \\

%The key generation algorithm is exactly the same as the original key generation algorithm. However, the only difference is that we repeat the  key generation algorithm until to make sure for all possible messages  $ m\in \M$ we have $  m < \frac{\sqrt{N}}{100}$. So basically, we can make sure that all the messages are co-prime to the chose secret keys.  \hassan{I wanted to make sure that this way of generating the secret keys are ok or not}
%\hassan{We may need to omit this part as we will discuss it when we present the construction.}

The encryption scheme has several homomorphic properties in particular if $c_1 = g^{m_1} r_1^N \mod{N^2}$ and $c_2= g^{m_2} r_2^N \mod{N^2}$ encrypt message $m_1,m_2 \in \mathbb{Z}_N$ respectively then $c_1c_2 = g^{m_1+m_2} (r_1r_2)^N \mod{N^2}$ encrypts the message $m_1+m_2 \mod N$. Similarly, if $c= g^m r^N \mod {N^2}$ encrypts the message $m$ then $c^k = g^{mk} (r^k)^N \mod {N^2}$ encrypts the message $mk \mod N$. See \appref{App:PailDetails} for a full description of the Paillier encryption scheme. \\

%\hassan{We can ignore this part in this paper. Just double check to see if we used this notation in the rest of the paper or not.} For convenience we define operations $\boxplus$ and $\boxminus$ where $c_1 \boxplus c_2 \doteq c_1 c_2 \mod{N^2}$ and $c_1 \boxminus c_2 \doteq c_1 c_2^{-1} \mod{N^2}$. Intuitively, if $c_1,c_2 \in \mathbb{Z}_{N^2}^*$ correspond to messages $m_1,m_2 \in \mathbb{Z}_N$ then the ciphertext $c=c_1 \boxplus c_2 \in \mathbb{Z}_{N^2}^*$ (resp. $c=c_1 \boxminus c_2 \in \mathbb{Z}_{N^2}$) encrypts the message $m_1+m_2 \mod N$ (resp. $m_1-m_2 \mod{N}$). Similarly, given $k \in \mathbb{Z}_N$ and ciphertext $c$ encrypting $m \in \mathbb{Z}_N$ we define $k \boxtimes c \doteq c^k \mod{N^2}$ which corresponds to the message $mk \mod{N}$. Finally, given ciphertexts $c_1,\ldots, c_k$ corresponding to messages $m_1,\ldots, m_k $  will be convenient to define $\BboxP_{i=1}^k c_i \doteq \prod_{i=1}^k c_i \mod{N^2}$  which corresponds to the message $\sum_{i=1}^k m_i \mod{N}$. \\


When we apply the Paillier Cryptosystem, our desired message space $\mathcal{M}$ is typically not the set of integers $\mathbb{Z}_N$. Thus, we assume that there is an \replaced{injective}{invective} map $ \ToInt: \mathcal{M} \to \Mbb{N} $ and $ \ToOrig: \Mbb{N} \to  \mathcal{M}$. We will also assume that $|\mathcal{M}| \leq N$ and that $\forall m \in \mathcal{M}$ that $0 \leq \ToInt(m) < \left| \mathcal{M}\right| \leq  N$. Given $x \in \mathbb{Z}_N$ we define $\ToOrig (x) = \bot$ if $x$ has no preimage i.e., $\forall m \in \mathcal{M}$ we have $\ToInt(m) \neq x$.
\subsubsection{Secret Sharing (SS)}\seclab{Sec:SecretSharing}
Several of our constructions rely on a primitive called secret sharing. A $(t,n)$-secret sharing scheme consists of two polynomial time algorithms $\mathtt{ShareGen}$ and $\recover$. Intuitively, $\left( \ldb s \rdb_1, \ldots,  \ldb s \rdb_n\right) \gets \mathtt{ShareGen}(n,t,s)$ takes as input a secret $s \in \mathbb{F}$ along with parameters $n,t$ and outputs $n$ shares $\left(\ldb s \rdb_1, \ldots, \ldb s \rdb_n\right) \in \mathbb{F}$. Given any subset $S = \{i_1,\ldots, i_t\} \subseteq [n]$ of $|S| = t$ shares we can recover the secret $s$ using  $$\recover\left(\left(i_1, \ldb s \rdb_{i_1}), \ldots, (i_t, \ldb s \rdb_{i_t}\right)\right) = s$$ However, given any smaller subset $S=\{i_1,\ldots, i_{t-1}\} \subseteq [n]$ of size $|S| \leq t-1$ shares an attacker cannot infer {\em anything} about $s$ from the shares $\ldb s \rdb_{i_1}, \ldots, \ldb s \rdb_{i_{t-1}}$. In particular, we require that  for all secrets $s \in \mathbb{F}$,  all subsets $S = \{i_1,\ldots, i_{t-1}\} \subseteq [n]$ of size $t-1$ the shares  $\ldb s \rdb_{i_1}, \ldots,  \ldb s \rdb_{i_{t-1}}$ can be viewed as uniformly random independent elements in $\mathbb{F}$ unrelated to the secret $s$. The Shamir Secret sharing scheme \cite{CACM:Shamir79} satisfies this requirement. See appendix \appref{Sec:SecretSharing} for more detail about (Shamir) Secret Sharing.

\subsubsection{String Distance and Close Passwords} Given a string $w \in \Sigma^n$ and $i \leq n$ we use $w[i] \in \Sigma$ to denote the $i$th character of $\Sigma$ and given two strings $w_1,w_2 \in \Sigma^n$ we use $\Ham(w_1,w_2) = \left|\{ i | w[i] \neq w[j]\} \right|$ to denote the hamming distance between them. Similarly, given two strings $w_1, w_2 \in \Sigma^*$ we use $\ED(w_1,w_2)$ to denote the edit-distance between them i.e., the minimum number of insertions/deletions to transform $w_1$ into $w_2$ (or vice versa). Note that if $w_1=w_2$ then $\Ham(w_1,w_2)=0$ and $\
\ED(w_1,w_2)=0$. We will often use Hamming/Edit Distance to determine if two passwords $\pwd_1,\pwd_2$ are close e.g., we could define a predicate $P(\pwd_1,\pwd_2)=1$ if $\Ham(\pwd_1, \pwd_2) \leq 2$ or $\ED(\pwd_1, \pwd_2) \leq 1$; otherwise $P(\pwd_1,\pwd_2)=0$. We could also combine Hamming/Edit distance with other common password typos such as CAPSLOCK/SHIFT errors e.g., $P(\pwd_1, \pwd_2)=1$ if $\InvertCase(\pwd_1) = \pwd_2$ or $\Ham(\pwd_1, \pwd_2) \leq 2$ or $\ED(\pwd_1, \pwd_2) \leq 1$; otherwise, $P(\pwd_1,\pwd_2)=0$.