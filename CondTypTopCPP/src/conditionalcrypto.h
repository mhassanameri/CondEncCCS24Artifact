//
// Created by mameriek on 9/17/21.
//

#ifndef CONDENCCPP_CONDITIONALCRYPTO_H
#define CONDENCCPP_CONDITIONALCRYPTO_H


#if defined(CRYPTOPP_CXX11_NULLPTR) && !defined(NULLPTR)
# define NULLPTR nullptr
#elif !defined(NULLPTR)
# define NULLPTR NULL
#endif // CRYPTOPP_CXX11_NULLPTR


#include <iostream>
using std::ostream;
using std::cout;
using std::cerr;
using std::endl;
using std::ios;

#include <iomanip>
#include <string>
#include <cassert>


#include "PaillierWrapperFunctions.h"
//#include "CryptoSymWrapperFunctions.h"


class ConditionalEncryption {
public:
    /* API Documentation
	 * Algorithm description: Raw encryption scheme which uses the traditional encryption schemes (here we use Partially
     * homomorphic encryption scheme.
	 * Inputs:
	 *    paillier_pubkey_t* ppk                - the public key for our conditional encryption scheme
     *                                              (a pallier public key)
	 *    const string &msg                     - the input message msg of arbitrary length
     *  Output:
     *    string &tx                            - the output ciphertext will be written here.
     * */

    static void Enc (paillier_pubkey_t* ppk, string &msg, string &ctx) ;



    /* API Documentation
	 * Algorithm description: Conditional Encryption algorithm which takes as input the traditional ctx corresponding
	 * to an unknown message m and two additional messages m1 and m2 (pallier plaintexts). Based on some target predicate P
	 * (e.g., hamming Distance two, edit distance one, OR etc...) generates the output ciphertext which will be valid
	 * encryption of m2 if and only if P(m,m1)=1. If P(m,m1)=0 then the output ciphertext should be random and leak no
	 * information about m, m1 or m2 even given access to the secret key.
	 * Inputs:
	 *    paillier_pubkey_t* ppk                - the public key for our conditional encryption scheme
     *                                              (a pallier public key)
	 *    const string& RlPwd_ctx_pull          - the input ciphertext of some (unknown) original message m
	 *    const string m1                       - input string which may or may not have P(typo,x) = 1
	 *    const string m2                       - the second message m2 to be conditionally encypted based on P(m,m1)
	 *    size_t _len                           - Determines the size of padded message
     *  Output:
     *    string out_ctx                       - the output ciphertext will be written here. If P(m,m1) = 0
     *                                           the ciphertext reveals nothing about m1,m2 or m even given
	 *                                            access to the secret key. Otherwise, out_ctx is a valid encryption of m2
     *
     * */

    static void CondEnc(paillier_pubkey_t* ppk, string& RlPwd_ctx_pull,
                        string m1, string m2,
                        string &out_ctx, size_t _len);


    /* API Documenation
	 * Conditional Encryption for Hamming Distance Two Predicate Using Shamir Secret Sharing: Decryption Algorithm
	 * Inputs:
	 *    const string &typo_ctx                - the conditional ciphertext to decrypt
     *    paillier_pubkey_t* ppk                - the public key for our conditional encryption scheme
     *                                              (a pallier public key)
	 *    paillier_prvkey_t* psk                - the secrtet  key for our conditional encryption scheme
     *                                              (a pallier secret key)
     *    int threshold                         - the threshold number of requirecd valid shares
     *                                              to recover the shared secret
	 *    string recovered                      - the decrypted message will be written here (might be garbage )
     *    size_t _len                           - Determines the size of original padded message
     *
     *    Returns 1 if the message was successfully recovered; -1 if recovery failed (this is to be expected in cases where the ciphertext was generated by ConditionalEnc, but the predicate P(m,m1)=0)
     * */
    static int CondDec (paillier_pubkey_t* ppk,
                         string &typo_ctx,
                         paillier_prvkey_t* psk,
                         int threshold, string &recovered,
                         size_t _len, size_t ShareSize ) ;

};

#endif // CONDENCCPP_CONDITIONALCRYPTO_H
